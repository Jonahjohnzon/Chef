{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _get = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar parser = require('postcss-value-parser');\n\nvar range = require('normalize-range');\n\nvar OldValue = require('../old-value');\n\nvar Value = require('../value');\n\nvar utils = require('../utils');\n\nvar IS_DIRECTION = /top|left|right|bottom/gi;\n\nvar Gradient = /*#__PURE__*/function (_Value) {\n  \"use strict\";\n\n  _inherits(Gradient, _Value);\n\n  var _super = _createSuper(Gradient);\n\n  function Gradient() {\n    _classCallCheck(this, Gradient);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Gradient, [{\n    key: \"replace\",\n    value:\n    /**\n     * Change degrees for webkit prefix\n     */\n    function replace(string, prefix) {\n      var ast = parser(string);\n\n      var _iterator = _createForOfIteratorHelper(ast.nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n\n          if (node.type === 'function' && node.value === this.name) {\n            node.nodes = this.newDirection(node.nodes);\n            node.nodes = this.normalize(node.nodes);\n\n            if (prefix === '-webkit- old') {\n              var changes = this.oldWebkit(node);\n\n              if (!changes) {\n                return false;\n              }\n            } else {\n              node.nodes = this.convertDirection(node.nodes);\n              node.value = prefix + node.value;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ast.toString();\n    }\n    /**\n     * Replace first token\n     */\n\n  }, {\n    key: \"replaceFirst\",\n    value: function replaceFirst(params) {\n      for (var _len = arguments.length, words = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        words[_key - 1] = arguments[_key];\n      }\n\n      var prefix = words.map(function (i) {\n        if (i === ' ') {\n          return {\n            type: 'space',\n            value: i\n          };\n        }\n\n        return {\n          type: 'word',\n          value: i\n        };\n      });\n      return prefix.concat(params.slice(1));\n    }\n    /**\n     * Convert angle unit to deg\n     */\n\n  }, {\n    key: \"normalizeUnit\",\n    value: function normalizeUnit(str, full) {\n      var num = parseFloat(str);\n      var deg = num / full * 360;\n      return \"\".concat(deg, \"deg\");\n    }\n    /**\n     * Normalize angle\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize(nodes) {\n      if (!nodes[0]) return nodes;\n\n      if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\n        nodes[0].value = this.normalizeUnit(nodes[0].value, 400);\n      } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\n        nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);\n      } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\n        nodes[0].value = this.normalizeUnit(nodes[0].value, 1);\n      } else if (nodes[0].value.includes('deg')) {\n        var num = parseFloat(nodes[0].value);\n        num = range.wrap(0, 360, num);\n        nodes[0].value = \"\".concat(num, \"deg\");\n      }\n\n      if (nodes[0].value === '0deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'top');\n      } else if (nodes[0].value === '90deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'right');\n      } else if (nodes[0].value === '180deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom');\n      } else if (nodes[0].value === '270deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'left');\n      }\n\n      return nodes;\n    }\n    /**\n     * Replace old direction to new\n     */\n\n  }, {\n    key: \"newDirection\",\n    value: function newDirection(params) {\n      if (params[0].value === 'to') {\n        return params;\n      }\n\n      IS_DIRECTION.lastIndex = 0; // reset search index of global regexp\n\n      if (!IS_DIRECTION.test(params[0].value)) {\n        return params;\n      }\n\n      params.unshift({\n        type: 'word',\n        value: 'to'\n      }, {\n        type: 'space',\n        value: ' '\n      });\n\n      for (var i = 2; i < params.length; i++) {\n        if (params[i].type === 'div') {\n          break;\n        }\n\n        if (params[i].type === 'word') {\n          params[i].value = this.revertDirection(params[i].value);\n        }\n      }\n\n      return params;\n    }\n    /**\n     * Look for at word\n     */\n\n  }, {\n    key: \"isRadial\",\n    value: function isRadial(params) {\n      var state = 'before';\n\n      var _iterator2 = _createForOfIteratorHelper(params),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var param = _step2.value;\n\n          if (state === 'before' && param.type === 'space') {\n            state = 'at';\n          } else if (state === 'at' && param.value === 'at') {\n            state = 'after';\n          } else if (state === 'after' && param.type === 'space') {\n            return true;\n          } else if (param.type === 'div') {\n            break;\n          } else {\n            state = 'before';\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n    /**\n     * Change new direction to old\n     */\n\n  }, {\n    key: \"convertDirection\",\n    value: function convertDirection(params) {\n      if (params.length > 0) {\n        if (params[0].value === 'to') {\n          this.fixDirection(params);\n        } else if (params[0].value.includes('deg')) {\n          this.fixAngle(params);\n        } else if (this.isRadial(params)) {\n          this.fixRadial(params);\n        }\n      }\n\n      return params;\n    }\n    /**\n     * Replace `to top left` to `bottom right`\n     */\n\n  }, {\n    key: \"fixDirection\",\n    value: function fixDirection(params) {\n      params.splice(0, 2);\n\n      var _iterator3 = _createForOfIteratorHelper(params),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var param = _step3.value;\n\n          if (param.type === 'div') {\n            break;\n          }\n\n          if (param.type === 'word') {\n            param.value = this.revertDirection(param.value);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Add 90 degrees\n     */\n\n  }, {\n    key: \"fixAngle\",\n    value: function fixAngle(params) {\n      var first = params[0].value;\n      first = parseFloat(first);\n      first = Math.abs(450 - first) % 360;\n      first = this.roundFloat(first, 3);\n      params[0].value = \"\".concat(first, \"deg\");\n    }\n    /**\n     * Fix radial direction syntax\n     */\n\n  }, {\n    key: \"fixRadial\",\n    value: function fixRadial(params) {\n      var first = [];\n      var second = [];\n      var a, b, c, i, next;\n\n      for (i = 0; i < params.length - 2; i++) {\n        a = params[i];\n        b = params[i + 1];\n        c = params[i + 2];\n\n        if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\n          next = i + 3;\n          break;\n        } else {\n          first.push(a);\n        }\n      }\n\n      var div;\n\n      for (i = next; i < params.length; i++) {\n        if (params[i].type === 'div') {\n          div = params[i];\n          break;\n        } else {\n          second.push(params[i]);\n        }\n      }\n\n      params.splice.apply(params, [0, i].concat(second, [div], first));\n    }\n  }, {\n    key: \"revertDirection\",\n    value: function revertDirection(word) {\n      return Gradient.directions[word.toLowerCase()] || word;\n    }\n    /**\n     * Round float and save digits under dot\n     */\n\n  }, {\n    key: \"roundFloat\",\n    value: function roundFloat(float, digits) {\n      return parseFloat(float.toFixed(digits));\n    }\n    /**\n     * Convert to old webkit syntax\n     */\n\n  }, {\n    key: \"oldWebkit\",\n    value: function oldWebkit(node) {\n      var nodes = node.nodes;\n      var string = parser.stringify(node.nodes);\n\n      if (this.name !== 'linear-gradient') {\n        return false;\n      }\n\n      if (nodes[0] && nodes[0].value.includes('deg')) {\n        return false;\n      }\n\n      if (string.includes('px') || string.includes('-corner') || string.includes('-side')) {\n        return false;\n      }\n\n      var params = [[]];\n\n      var _iterator4 = _createForOfIteratorHelper(nodes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var i = _step4.value;\n          params[params.length - 1].push(i);\n\n          if (i.type === 'div' && i.value === ',') {\n            params.push([]);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.oldDirection(params);\n      this.colorStops(params);\n      node.nodes = [];\n\n      for (var _i = 0, _params = params; _i < _params.length; _i++) {\n        var param = _params[_i];\n        node.nodes = node.nodes.concat(param);\n      }\n\n      node.nodes.unshift({\n        type: 'word',\n        value: 'linear'\n      }, this.cloneDiv(node.nodes));\n      node.value = '-webkit-gradient';\n      return true;\n    }\n    /**\n     * Change direction syntax to old webkit\n     */\n\n  }, {\n    key: \"oldDirection\",\n    value: function oldDirection(params) {\n      var div = this.cloneDiv(params[0]);\n\n      if (params[0][0].value !== 'to') {\n        return params.unshift([{\n          type: 'word',\n          value: Gradient.oldDirections.bottom\n        }, div]);\n      } else {\n        var words = [];\n\n        var _iterator5 = _createForOfIteratorHelper(params[0].slice(2)),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var node = _step5.value;\n\n            if (node.type === 'word') {\n              words.push(node.value.toLowerCase());\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        words = words.join(' ');\n        var old = Gradient.oldDirections[words] || words;\n        params[0] = [{\n          type: 'word',\n          value: old\n        }, div];\n        return params[0];\n      }\n    }\n    /**\n     * Get div token from exists parameters\n     */\n\n  }, {\n    key: \"cloneDiv\",\n    value: function cloneDiv(params) {\n      var _iterator6 = _createForOfIteratorHelper(params),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var i = _step6.value;\n\n          if (i.type === 'div' && i.value === ',') {\n            return i;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return {\n        type: 'div',\n        value: ',',\n        after: ' '\n      };\n    }\n    /**\n     * Change colors syntax to old webkit\n     */\n\n  }, {\n    key: \"colorStops\",\n    value: function colorStops(params) {\n      var result = [];\n\n      for (var i = 0; i < params.length; i++) {\n        var pos = void 0;\n        var param = params[i];\n        var item = void 0;\n\n        if (i === 0) {\n          continue;\n        }\n\n        var color = parser.stringify(param[0]);\n\n        if (param[1] && param[1].type === 'word') {\n          pos = param[1].value;\n        } else if (param[2] && param[2].type === 'word') {\n          pos = param[2].value;\n        }\n\n        var stop = void 0;\n\n        if (i === 1 && (!pos || pos === '0%')) {\n          stop = \"from(\".concat(color, \")\");\n        } else if (i === params.length - 1 && (!pos || pos === '100%')) {\n          stop = \"to(\".concat(color, \")\");\n        } else if (pos) {\n          stop = \"color-stop(\".concat(pos, \", \").concat(color, \")\");\n        } else {\n          stop = \"color-stop(\".concat(color, \")\");\n        }\n\n        var div = param[param.length - 1];\n        params[i] = [{\n          type: 'word',\n          value: stop\n        }];\n\n        if (div.type === 'div' && div.value === ',') {\n          item = params[i].push(div);\n        }\n\n        result.push(item);\n      }\n\n      return result;\n    }\n    /**\n     * Remove old WebKit gradient too\n     */\n\n  }, {\n    key: \"old\",\n    value: function old(prefix) {\n      if (prefix === '-webkit-') {\n        var type = this.name === 'linear-gradient' ? 'linear' : 'radial';\n        var string = '-gradient';\n        var regexp = utils.regexp(\"-webkit-(\".concat(type, \"-gradient|gradient\\\\(\\\\s*\").concat(type, \")\"), false);\n        return new OldValue(this.name, prefix + this.name, string, regexp);\n      } else {\n        return _get(_getPrototypeOf(Gradient.prototype), \"old\", this).call(this, prefix);\n      }\n    }\n    /**\n     * Do not add non-webkit prefixes for list-style and object\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(decl, prefix) {\n      var p = decl.prop;\n\n      if (p.includes('mask')) {\n        if (prefix === '-webkit-' || prefix === '-webkit- old') {\n          return _get(_getPrototypeOf(Gradient.prototype), \"add\", this).call(this, decl, prefix);\n        }\n      } else if (p === 'list-style' || p === 'list-style-image' || p === 'content') {\n        if (prefix === '-webkit-' || prefix === '-webkit- old') {\n          return _get(_getPrototypeOf(Gradient.prototype), \"add\", this).call(this, decl, prefix);\n        }\n      } else {\n        return _get(_getPrototypeOf(Gradient.prototype), \"add\", this).call(this, decl, prefix);\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return Gradient;\n}(Value);\n\nGradient.names = ['linear-gradient', 'repeating-linear-gradient', 'radial-gradient', 'repeating-radial-gradient'];\nGradient.directions = {\n  top: 'bottom',\n  left: 'right',\n  bottom: 'top',\n  right: 'left'\n}; // Direction to replace\n\nGradient.oldDirections = {\n  'top': 'left bottom, left top',\n  'left': 'right top, left top',\n  'bottom': 'left top, left bottom',\n  'right': 'left top, right top',\n  'top right': 'left bottom, right top',\n  'top left': 'right bottom, left top',\n  'right top': 'left bottom, right top',\n  'right bottom': 'left top, right bottom',\n  'bottom right': 'left top, right bottom',\n  'bottom left': 'right top, left bottom',\n  'left top': 'right bottom, left top',\n  'left bottom': 'right top, left bottom'\n};\nmodule.exports = Gradient;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/hacks/gradient.js"],"names":["parser","require","range","OldValue","Value","utils","IS_DIRECTION","Gradient","string","prefix","ast","nodes","node","type","value","name","newDirection","normalize","changes","oldWebkit","convertDirection","toString","params","words","map","i","concat","slice","str","full","num","parseFloat","deg","test","normalizeUnit","Math","PI","includes","wrap","replaceFirst","lastIndex","unshift","length","revertDirection","state","param","fixDirection","fixAngle","isRadial","fixRadial","splice","first","abs","roundFloat","second","a","b","c","next","push","div","word","directions","toLowerCase","float","digits","toFixed","stringify","oldDirection","colorStops","cloneDiv","oldDirections","bottom","join","old","after","result","pos","item","color","stop","regexp","decl","p","prop","undefined","names","top","left","right","module","exports"],"mappings":"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","sourcesContent":["let parser = require('postcss-value-parser')\nlet range = require('normalize-range')\n\nlet OldValue = require('../old-value')\nlet Value = require('../value')\nlet utils = require('../utils')\n\nlet IS_DIRECTION = /top|left|right|bottom/gi\n\nclass Gradient extends Value {\n  /**\n   * Change degrees for webkit prefix\n   */\n  replace(string, prefix) {\n    let ast = parser(string)\n    for (let node of ast.nodes) {\n      if (node.type === 'function' && node.value === this.name) {\n        node.nodes = this.newDirection(node.nodes)\n        node.nodes = this.normalize(node.nodes)\n        if (prefix === '-webkit- old') {\n          let changes = this.oldWebkit(node)\n          if (!changes) {\n            return false\n          }\n        } else {\n          node.nodes = this.convertDirection(node.nodes)\n          node.value = prefix + node.value\n        }\n      }\n    }\n    return ast.toString()\n  }\n\n  /**\n   * Replace first token\n   */\n  replaceFirst(params, ...words) {\n    let prefix = words.map(i => {\n      if (i === ' ') {\n        return { type: 'space', value: i }\n      }\n      return { type: 'word', value: i }\n    })\n    return prefix.concat(params.slice(1))\n  }\n\n  /**\n   * Convert angle unit to deg\n   */\n  normalizeUnit(str, full) {\n    let num = parseFloat(str)\n    let deg = (num / full) * 360\n    return `${deg}deg`\n  }\n\n  /**\n   * Normalize angle\n   */\n  normalize(nodes) {\n    if (!nodes[0]) return nodes\n\n    if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)\n    } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)\n    } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)\n    } else if (nodes[0].value.includes('deg')) {\n      let num = parseFloat(nodes[0].value)\n      num = range.wrap(0, 360, num)\n      nodes[0].value = `${num}deg`\n    }\n\n    if (nodes[0].value === '0deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'top')\n    } else if (nodes[0].value === '90deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'right')\n    } else if (nodes[0].value === '180deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom')\n    } else if (nodes[0].value === '270deg') {\n      nodes = this.replaceFirst(nodes, 'to', ' ', 'left')\n    }\n\n    return nodes\n  }\n\n  /**\n   * Replace old direction to new\n   */\n  newDirection(params) {\n    if (params[0].value === 'to') {\n      return params\n    }\n    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp\n    if (!IS_DIRECTION.test(params[0].value)) {\n      return params\n    }\n\n    params.unshift(\n      {\n        type: 'word',\n        value: 'to'\n      },\n      {\n        type: 'space',\n        value: ' '\n      }\n    )\n\n    for (let i = 2; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        break\n      }\n      if (params[i].type === 'word') {\n        params[i].value = this.revertDirection(params[i].value)\n      }\n    }\n\n    return params\n  }\n\n  /**\n   * Look for at word\n   */\n  isRadial(params) {\n    let state = 'before'\n    for (let param of params) {\n      if (state === 'before' && param.type === 'space') {\n        state = 'at'\n      } else if (state === 'at' && param.value === 'at') {\n        state = 'after'\n      } else if (state === 'after' && param.type === 'space') {\n        return true\n      } else if (param.type === 'div') {\n        break\n      } else {\n        state = 'before'\n      }\n    }\n    return false\n  }\n\n  /**\n   * Change new direction to old\n   */\n  convertDirection(params) {\n    if (params.length > 0) {\n      if (params[0].value === 'to') {\n        this.fixDirection(params)\n      } else if (params[0].value.includes('deg')) {\n        this.fixAngle(params)\n      } else if (this.isRadial(params)) {\n        this.fixRadial(params)\n      }\n    }\n    return params\n  }\n\n  /**\n   * Replace `to top left` to `bottom right`\n   */\n  fixDirection(params) {\n    params.splice(0, 2)\n\n    for (let param of params) {\n      if (param.type === 'div') {\n        break\n      }\n      if (param.type === 'word') {\n        param.value = this.revertDirection(param.value)\n      }\n    }\n  }\n\n  /**\n   * Add 90 degrees\n   */\n  fixAngle(params) {\n    let first = params[0].value\n    first = parseFloat(first)\n    first = Math.abs(450 - first) % 360\n    first = this.roundFloat(first, 3)\n    params[0].value = `${first}deg`\n  }\n\n  /**\n   * Fix radial direction syntax\n   */\n  fixRadial(params) {\n    let first = []\n    let second = []\n    let a, b, c, i, next\n\n    for (i = 0; i < params.length - 2; i++) {\n      a = params[i]\n      b = params[i + 1]\n      c = params[i + 2]\n      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\n        next = i + 3\n        break\n      } else {\n        first.push(a)\n      }\n    }\n\n    let div\n    for (i = next; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        div = params[i]\n        break\n      } else {\n        second.push(params[i])\n      }\n    }\n\n    params.splice(0, i, ...second, div, ...first)\n  }\n\n  revertDirection(word) {\n    return Gradient.directions[word.toLowerCase()] || word\n  }\n\n  /**\n   * Round float and save digits under dot\n   */\n  roundFloat(float, digits) {\n    return parseFloat(float.toFixed(digits))\n  }\n\n  /**\n   * Convert to old webkit syntax\n   */\n  oldWebkit(node) {\n    let { nodes } = node\n    let string = parser.stringify(node.nodes)\n\n    if (this.name !== 'linear-gradient') {\n      return false\n    }\n    if (nodes[0] && nodes[0].value.includes('deg')) {\n      return false\n    }\n    if (\n      string.includes('px') ||\n      string.includes('-corner') ||\n      string.includes('-side')\n    ) {\n      return false\n    }\n\n    let params = [[]]\n    for (let i of nodes) {\n      params[params.length - 1].push(i)\n      if (i.type === 'div' && i.value === ',') {\n        params.push([])\n      }\n    }\n\n    this.oldDirection(params)\n    this.colorStops(params)\n\n    node.nodes = []\n    for (let param of params) {\n      node.nodes = node.nodes.concat(param)\n    }\n\n    node.nodes.unshift(\n      { type: 'word', value: 'linear' },\n      this.cloneDiv(node.nodes)\n    )\n    node.value = '-webkit-gradient'\n\n    return true\n  }\n\n  /**\n   * Change direction syntax to old webkit\n   */\n  oldDirection(params) {\n    let div = this.cloneDiv(params[0])\n\n    if (params[0][0].value !== 'to') {\n      return params.unshift([\n        { type: 'word', value: Gradient.oldDirections.bottom },\n        div\n      ])\n    } else {\n      let words = []\n      for (let node of params[0].slice(2)) {\n        if (node.type === 'word') {\n          words.push(node.value.toLowerCase())\n        }\n      }\n\n      words = words.join(' ')\n      let old = Gradient.oldDirections[words] || words\n\n      params[0] = [{ type: 'word', value: old }, div]\n      return params[0]\n    }\n  }\n\n  /**\n   * Get div token from exists parameters\n   */\n  cloneDiv(params) {\n    for (let i of params) {\n      if (i.type === 'div' && i.value === ',') {\n        return i\n      }\n    }\n    return { type: 'div', value: ',', after: ' ' }\n  }\n\n  /**\n   * Change colors syntax to old webkit\n   */\n  colorStops(params) {\n    let result = []\n    for (let i = 0; i < params.length; i++) {\n      let pos\n      let param = params[i]\n      let item\n      if (i === 0) {\n        continue\n      }\n\n      let color = parser.stringify(param[0])\n      if (param[1] && param[1].type === 'word') {\n        pos = param[1].value\n      } else if (param[2] && param[2].type === 'word') {\n        pos = param[2].value\n      }\n\n      let stop\n      if (i === 1 && (!pos || pos === '0%')) {\n        stop = `from(${color})`\n      } else if (i === params.length - 1 && (!pos || pos === '100%')) {\n        stop = `to(${color})`\n      } else if (pos) {\n        stop = `color-stop(${pos}, ${color})`\n      } else {\n        stop = `color-stop(${color})`\n      }\n\n      let div = param[param.length - 1]\n      params[i] = [{ type: 'word', value: stop }]\n      if (div.type === 'div' && div.value === ',') {\n        item = params[i].push(div)\n      }\n      result.push(item)\n    }\n    return result\n  }\n\n  /**\n   * Remove old WebKit gradient too\n   */\n  old(prefix) {\n    if (prefix === '-webkit-') {\n      let type = this.name === 'linear-gradient' ? 'linear' : 'radial'\n      let string = '-gradient'\n      let regexp = utils.regexp(\n        `-webkit-(${type}-gradient|gradient\\\\(\\\\s*${type})`,\n        false\n      )\n\n      return new OldValue(this.name, prefix + this.name, string, regexp)\n    } else {\n      return super.old(prefix)\n    }\n  }\n\n  /**\n   * Do not add non-webkit prefixes for list-style and object\n   */\n  add(decl, prefix) {\n    let p = decl.prop\n    if (p.includes('mask')) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix)\n      }\n    } else if (\n      p === 'list-style' ||\n      p === 'list-style-image' ||\n      p === 'content'\n    ) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix)\n      }\n    } else {\n      return super.add(decl, prefix)\n    }\n    return undefined\n  }\n}\n\nGradient.names = [\n  'linear-gradient',\n  'repeating-linear-gradient',\n  'radial-gradient',\n  'repeating-radial-gradient'\n]\n\nGradient.directions = {\n  top: 'bottom',\n  left: 'right',\n  bottom: 'top',\n  right: 'left'\n}\n\n// Direction to replace\nGradient.oldDirections = {\n  'top': 'left bottom, left top',\n  'left': 'right top, left top',\n  'bottom': 'left top, left bottom',\n  'right': 'left top, right top',\n\n  'top right': 'left bottom, right top',\n  'top left': 'right bottom, left top',\n  'right top': 'left bottom, right top',\n  'right bottom': 'left top, right bottom',\n  'bottom right': 'left top, right bottom',\n  'bottom left': 'right top, left bottom',\n  'left top': 'right bottom, left top',\n  'left bottom': 'right top, left bottom'\n}\n\nmodule.exports = Gradient\n"]},"metadata":{},"sourceType":"script"}