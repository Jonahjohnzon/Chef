{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('postcss'),\n    list = _require.list;\n\nvar OldSelector = require('./old-selector');\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Selector = /*#__PURE__*/function (_Prefixer) {\n  \"use strict\";\n\n  _inherits(Selector, _Prefixer);\n\n  var _super = _createSuper(Selector);\n\n  function Selector(name, prefixes, all) {\n    var _this;\n\n    _classCallCheck(this, Selector);\n\n    _this = _super.call(this, name, prefixes, all);\n    _this.regexpCache = new Map();\n    return _this;\n  }\n  /**\n   * Is rule selectors need to be prefixed\n   */\n\n\n  _createClass(Selector, [{\n    key: \"check\",\n    value: function check(rule) {\n      if (rule.selector.includes(this.name)) {\n        return !!rule.selector.match(this.regexp());\n      }\n\n      return false;\n    }\n    /**\n     * Return prefixed version of selector\n     */\n\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(prefix) {\n      return this.name.replace(/^(\\W*)/, \"$1\".concat(prefix));\n    }\n    /**\n     * Lazy loadRegExp for name\n     */\n\n  }, {\n    key: \"regexp\",\n    value: function regexp(prefix) {\n      if (!this.regexpCache.has(prefix)) {\n        var name = prefix ? this.prefixed(prefix) : this.name;\n        this.regexpCache.set(prefix, new RegExp(\"(^|[^:\\\"'=])\".concat(utils.escapeRegexp(name)), 'gi'));\n      }\n\n      return this.regexpCache.get(prefix);\n    }\n    /**\n     * All possible prefixes\n     */\n\n  }, {\n    key: \"possible\",\n    value: function possible() {\n      return Browsers.prefixes();\n    }\n    /**\n     * Return all possible selector prefixes\n     */\n\n  }, {\n    key: \"prefixeds\",\n    value: function prefixeds(rule) {\n      var _this2 = this;\n\n      if (rule._autoprefixerPrefixeds) {\n        if (rule._autoprefixerPrefixeds[this.name]) {\n          return rule._autoprefixerPrefixeds;\n        }\n      } else {\n        rule._autoprefixerPrefixeds = {};\n      }\n\n      var prefixeds = {};\n\n      if (rule.selector.includes(',')) {\n        var ruleParts = list.comma(rule.selector);\n        var toProcess = ruleParts.filter(function (el) {\n          return el.includes(_this2.name);\n        });\n\n        var _iterator = _createForOfIteratorHelper(this.possible()),\n            _step;\n\n        try {\n          var _loop = function _loop() {\n            var prefix = _step.value;\n            prefixeds[prefix] = toProcess.map(function (el) {\n              return _this2.replace(el, prefix);\n            }).join(', ');\n          };\n\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(this.possible()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var prefix = _step2.value;\n            prefixeds[prefix] = this.replace(rule.selector, prefix);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      rule._autoprefixerPrefixeds[this.name] = prefixeds;\n      return rule._autoprefixerPrefixeds;\n    }\n    /**\n     * Is rule already prefixed before\n     */\n\n  }, {\n    key: \"already\",\n    value: function already(rule, prefixeds, prefix) {\n      var index = rule.parent.index(rule) - 1;\n\n      while (index >= 0) {\n        var before = rule.parent.nodes[index];\n\n        if (before.type !== 'rule') {\n          return false;\n        }\n\n        var some = false;\n\n        for (var key in prefixeds[this.name]) {\n          var prefixed = prefixeds[this.name][key];\n\n          if (before.selector === prefixed) {\n            if (prefix === key) {\n              return true;\n            } else {\n              some = true;\n              break;\n            }\n          }\n        }\n\n        if (!some) {\n          return false;\n        }\n\n        index -= 1;\n      }\n\n      return false;\n    }\n    /**\n     * Replace selectors by prefixed one\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(selector, prefix) {\n      return selector.replace(this.regexp(), \"$1\".concat(this.prefixed(prefix)));\n    }\n    /**\n     * Clone and add prefixes for at-rule\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(rule, prefix) {\n      var prefixeds = this.prefixeds(rule);\n\n      if (this.already(rule, prefixeds, prefix)) {\n        return;\n      }\n\n      var cloned = this.clone(rule, {\n        selector: prefixeds[this.name][prefix]\n      });\n      rule.parent.insertBefore(rule, cloned);\n    }\n    /**\n     * Return function to fast find prefixed selector\n     */\n\n  }, {\n    key: \"old\",\n    value: function old(prefix) {\n      return new OldSelector(this, prefix);\n    }\n  }]);\n\n  return Selector;\n}(Prefixer);\n\nmodule.exports = Selector;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/selector.js"],"names":["require","list","OldSelector","Prefixer","Browsers","utils","Selector","name","prefixes","all","regexpCache","Map","rule","selector","includes","match","regexp","prefix","replace","has","prefixed","set","RegExp","escapeRegexp","get","_autoprefixerPrefixeds","prefixeds","ruleParts","comma","toProcess","filter","el","possible","map","join","index","parent","before","nodes","type","some","key","already","cloned","clone","insertBefore","module","exports"],"mappings":"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","sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix)\n  }\n}\n\nmodule.exports = Selector\n"]},"metadata":{},"sourceType":"script"}