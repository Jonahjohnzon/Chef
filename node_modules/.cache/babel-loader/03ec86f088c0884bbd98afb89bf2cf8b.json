{"ast":null,"code":"var _slicedToArray = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _require = require('postcss'),\n    list = _require.list;\n\nvar parser = require('postcss-value-parser');\n\nvar Browsers = require('./browsers');\n\nvar vendor = require('./vendor');\n\nvar Transition = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Transition(prefixes) {\n    _classCallCheck(this, Transition);\n\n    this.props = ['transition', 'transition-property'];\n    this.prefixes = prefixes;\n  }\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n\n\n  _createClass(Transition, [{\n    key: \"add\",\n    value: function add(decl, result) {\n      var _this = this;\n\n      var prefix, prop;\n      var add = this.prefixes.add[decl.prop];\n      var vendorPrefixes = this.ruleVendorPrefixes(decl);\n      var declPrefixes = vendorPrefixes || add && add.prefixes || [];\n      var params = this.parse(decl.value);\n      var names = params.map(function (i) {\n        return _this.findProp(i);\n      });\n      var added = [];\n\n      if (names.some(function (i) {\n        return i[0] === '-';\n      })) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper(params),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          prop = this.findProp(param);\n          if (prop[0] === '-') continue;\n          var prefixer = this.prefixes.add[prop];\n          if (!prefixer || !prefixer.prefixes) continue;\n\n          var _iterator3 = _createForOfIteratorHelper(prefixer.prefixes),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              prefix = _step3.value;\n\n              if (vendorPrefixes && !vendorPrefixes.some(function (p) {\n                return prefix.includes(p);\n              })) {\n                continue;\n              }\n\n              var prefixed = this.prefixes.prefixed(prop, prefix);\n\n              if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n                if (!this.disabled(prop, prefix)) {\n                  added.push(this.clone(prop, prefixed, param));\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      params = params.concat(added);\n      var value = this.stringify(params);\n      var webkitClean = this.stringify(this.cleanFromUnprefixed(params, '-webkit-'));\n\n      if (declPrefixes.includes('-webkit-')) {\n        this.cloneBefore(decl, \"-webkit-\".concat(decl.prop), webkitClean);\n      }\n\n      this.cloneBefore(decl, decl.prop, webkitClean);\n\n      if (declPrefixes.includes('-o-')) {\n        var operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));\n        this.cloneBefore(decl, \"-o-\".concat(decl.prop), operaClean);\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(declPrefixes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          prefix = _step2.value;\n\n          if (prefix !== '-webkit-' && prefix !== '-o-') {\n            var prefixValue = this.stringify(this.cleanOtherPrefixes(params, prefix));\n            this.cloneBefore(decl, prefix + decl.prop, prefixValue);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n        this.checkForWarning(result, decl);\n        decl.cloneBefore();\n        decl.value = value;\n      }\n    }\n    /**\n     * Find property name\n     */\n\n  }, {\n    key: \"findProp\",\n    value: function findProp(param) {\n      var prop = param[0].value;\n\n      if (/^\\d/.test(prop)) {\n        var _iterator4 = _createForOfIteratorHelper(param.entries()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                i = _step4$value[0],\n                token = _step4$value[1];\n\n            if (i !== 0 && token.type === 'word') {\n              return token.value;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return prop;\n    }\n    /**\n     * Does we already have this declaration\n     */\n\n  }, {\n    key: \"already\",\n    value: function already(decl, prop, value) {\n      return decl.parent.some(function (i) {\n        return i.prop === prop && i.value === value;\n      });\n    }\n    /**\n     * Add declaration if it is not exist\n     */\n\n  }, {\n    key: \"cloneBefore\",\n    value: function cloneBefore(decl, prop, value) {\n      if (!this.already(decl, prop, value)) {\n        decl.cloneBefore({\n          prop: prop,\n          value: value\n        });\n      }\n    }\n    /**\n     * Show transition-property warning\n     */\n\n  }, {\n    key: \"checkForWarning\",\n    value: function checkForWarning(result, decl) {\n      var _this2 = this;\n\n      if (decl.prop !== 'transition-property') {\n        return;\n      }\n\n      var isPrefixed = false;\n      var hasAssociatedProp = false;\n      decl.parent.each(function (i) {\n        if (i.type !== 'decl') {\n          return undefined;\n        }\n\n        if (i.prop.indexOf('transition-') !== 0) {\n          return undefined;\n        }\n\n        var values = list.comma(i.value); // check if current Rule's transition-property comma separated value list needs prefixes\n\n        if (i.prop === 'transition-property') {\n          values.forEach(function (value) {\n            var lookup = _this2.prefixes.add[value];\n\n            if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n              isPrefixed = true;\n            }\n          });\n          return undefined;\n        } // check if another transition-* prop in current Rule has comma separated value list\n\n\n        hasAssociatedProp = hasAssociatedProp || values.length > 1;\n        return false;\n      });\n\n      if (isPrefixed && hasAssociatedProp) {\n        decl.warn(result, 'Replace transition-property to transition, ' + 'because Autoprefixer could not support ' + 'any cases of transition-property ' + 'and other transition-*');\n      }\n    }\n    /**\n     * Process transition and remove all unnecessary properties\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(decl) {\n      var _this3 = this;\n\n      var params = this.parse(decl.value);\n      params = params.filter(function (i) {\n        var prop = _this3.prefixes.remove[_this3.findProp(i)];\n\n        return !prop || !prop.remove;\n      });\n      var value = this.stringify(params);\n\n      if (decl.value === value) {\n        return;\n      }\n\n      if (params.length === 0) {\n        decl.remove();\n        return;\n      }\n\n      var double = decl.parent.some(function (i) {\n        return i.prop === decl.prop && i.value === value;\n      });\n      var smaller = decl.parent.some(function (i) {\n        return i !== decl && i.prop === decl.prop && i.value.length > value.length;\n      });\n\n      if (double || smaller) {\n        decl.remove();\n        return;\n      }\n\n      decl.value = value;\n    }\n    /**\n     * Parse properties list to array\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(value) {\n      var ast = parser(value);\n      var result = [];\n      var param = [];\n\n      var _iterator5 = _createForOfIteratorHelper(ast.nodes),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var node = _step5.value;\n          param.push(node);\n\n          if (node.type === 'div' && node.value === ',') {\n            result.push(param);\n            param = [];\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      result.push(param);\n      return result.filter(function (i) {\n        return i.length > 0;\n      });\n    }\n    /**\n     * Return properties string from array\n     */\n\n  }, {\n    key: \"stringify\",\n    value: function stringify(params) {\n      if (params.length === 0) {\n        return '';\n      }\n\n      var nodes = [];\n\n      var _iterator6 = _createForOfIteratorHelper(params),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var param = _step6.value;\n\n          if (param[param.length - 1].type !== 'div') {\n            param.push(this.div(params));\n          }\n\n          nodes = nodes.concat(param);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (nodes[0].type === 'div') {\n        nodes = nodes.slice(1);\n      }\n\n      if (nodes[nodes.length - 1].type === 'div') {\n        nodes = nodes.slice(0, +-2 + 1 || undefined);\n      }\n\n      return parser.stringify({\n        nodes: nodes\n      });\n    }\n    /**\n     * Return new param array with different name\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(origin, name, param) {\n      var result = [];\n      var changed = false;\n\n      var _iterator7 = _createForOfIteratorHelper(param),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n\n          if (!changed && i.type === 'word' && i.value === origin) {\n            result.push({\n              type: 'word',\n              value: name\n            });\n            changed = true;\n          } else {\n            result.push(i);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return result;\n    }\n    /**\n     * Find or create separator\n     */\n\n  }, {\n    key: \"div\",\n    value: function div(params) {\n      var _iterator8 = _createForOfIteratorHelper(params),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var param = _step8.value;\n\n          var _iterator9 = _createForOfIteratorHelper(param),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var node = _step9.value;\n\n              if (node.type === 'div' && node.value === ',') {\n                return node;\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return {\n        type: 'div',\n        value: ',',\n        after: ' '\n      };\n    }\n  }, {\n    key: \"cleanOtherPrefixes\",\n    value: function cleanOtherPrefixes(params, prefix) {\n      var _this4 = this;\n\n      return params.filter(function (param) {\n        var current = vendor.prefix(_this4.findProp(param));\n        return current === '' || current === prefix;\n      });\n    }\n    /**\n     * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n     */\n\n  }, {\n    key: \"cleanFromUnprefixed\",\n    value: function cleanFromUnprefixed(params, prefix) {\n      var _this5 = this;\n\n      var remove = params.map(function (i) {\n        return _this5.findProp(i);\n      }).filter(function (i) {\n        return i.slice(0, prefix.length) === prefix;\n      }).map(function (i) {\n        return _this5.prefixes.unprefixed(i);\n      });\n      var result = [];\n\n      var _iterator10 = _createForOfIteratorHelper(params),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var param = _step10.value;\n          var prop = this.findProp(param);\n          var p = vendor.prefix(prop);\n\n          if (!remove.includes(prop) && (p === prefix || p === '')) {\n            result.push(param);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return result;\n    }\n    /**\n     * Check property for disabled by option\n     */\n\n  }, {\n    key: \"disabled\",\n    value: function disabled(prop, prefix) {\n      var other = ['order', 'justify-content', 'align-self', 'align-content'];\n\n      if (prop.includes('flex') || other.includes(prop)) {\n        if (this.prefixes.options.flexbox === false) {\n          return true;\n        }\n\n        if (this.prefixes.options.flexbox === 'no-2009') {\n          return prefix.includes('2009');\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Check if transition prop is inside vendor specific rule\n     */\n\n  }, {\n    key: \"ruleVendorPrefixes\",\n    value: function ruleVendorPrefixes(decl) {\n      var parent = decl.parent;\n\n      if (parent.type !== 'rule') {\n        return false;\n      } else if (!parent.selector.includes(':-')) {\n        return false;\n      }\n\n      var selectors = Browsers.prefixes().filter(function (s) {\n        return parent.selector.includes(':' + s);\n      });\n      return selectors.length > 0 ? selectors : false;\n    }\n  }]);\n\n  return Transition;\n}();\n\nmodule.exports = Transition;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/transition.js"],"names":["require","list","parser","Browsers","vendor","Transition","prefixes","props","decl","result","prefix","prop","add","vendorPrefixes","ruleVendorPrefixes","declPrefixes","params","parse","value","names","map","i","findProp","added","some","param","prefixer","p","includes","prefixed","disabled","push","clone","concat","stringify","webkitClean","cleanFromUnprefixed","cloneBefore","operaClean","prefixValue","cleanOtherPrefixes","already","checkForWarning","test","entries","token","type","parent","isPrefixed","hasAssociatedProp","each","undefined","indexOf","values","comma","forEach","lookup","length","warn","filter","remove","double","smaller","ast","nodes","node","div","slice","origin","name","changed","after","current","unprefixed","other","options","flexbox","selector","selectors","s","module","exports"],"mappings":"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","sourcesContent":["let { list } = require('postcss')\nlet parser = require('postcss-value-parser')\n\nlet Browsers = require('./browsers')\nlet vendor = require('./vendor')\n\nclass Transition {\n  constructor(prefixes) {\n    this.props = ['transition', 'transition-property']\n    this.prefixes = prefixes\n  }\n\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n  add(decl, result) {\n    let prefix, prop\n    let add = this.prefixes.add[decl.prop]\n    let vendorPrefixes = this.ruleVendorPrefixes(decl)\n    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []\n\n    let params = this.parse(decl.value)\n    let names = params.map(i => this.findProp(i))\n    let added = []\n\n    if (names.some(i => i[0] === '-')) {\n      return\n    }\n\n    for (let param of params) {\n      prop = this.findProp(param)\n      if (prop[0] === '-') continue\n\n      let prefixer = this.prefixes.add[prop]\n      if (!prefixer || !prefixer.prefixes) continue\n\n      for (prefix of prefixer.prefixes) {\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\n          continue\n        }\n\n        let prefixed = this.prefixes.prefixed(prop, prefix)\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n          if (!this.disabled(prop, prefix)) {\n            added.push(this.clone(prop, prefixed, param))\n          }\n        }\n      }\n    }\n\n    params = params.concat(added)\n    let value = this.stringify(params)\n\n    let webkitClean = this.stringify(\n      this.cleanFromUnprefixed(params, '-webkit-')\n    )\n    if (declPrefixes.includes('-webkit-')) {\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)\n    }\n    this.cloneBefore(decl, decl.prop, webkitClean)\n    if (declPrefixes.includes('-o-')) {\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)\n    }\n\n    for (prefix of declPrefixes) {\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\n        let prefixValue = this.stringify(\n          this.cleanOtherPrefixes(params, prefix)\n        )\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue)\n      }\n    }\n\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n      this.checkForWarning(result, decl)\n      decl.cloneBefore()\n      decl.value = value\n    }\n  }\n\n  /**\n   * Find property name\n   */\n  findProp(param) {\n    let prop = param[0].value\n    if (/^\\d/.test(prop)) {\n      for (let [i, token] of param.entries()) {\n        if (i !== 0 && token.type === 'word') {\n          return token.value\n        }\n      }\n    }\n    return prop\n  }\n\n  /**\n   * Does we already have this declaration\n   */\n  already(decl, prop, value) {\n    return decl.parent.some(i => i.prop === prop && i.value === value)\n  }\n\n  /**\n   * Add declaration if it is not exist\n   */\n  cloneBefore(decl, prop, value) {\n    if (!this.already(decl, prop, value)) {\n      decl.cloneBefore({ prop, value })\n    }\n  }\n\n  /**\n   * Show transition-property warning\n   */\n  checkForWarning(result, decl) {\n    if (decl.prop !== 'transition-property') {\n      return\n    }\n\n    let isPrefixed = false\n    let hasAssociatedProp = false\n\n    decl.parent.each(i => {\n      if (i.type !== 'decl') {\n        return undefined\n      }\n      if (i.prop.indexOf('transition-') !== 0) {\n        return undefined\n      }\n      let values = list.comma(i.value)\n      // check if current Rule's transition-property comma separated value list needs prefixes\n      if (i.prop === 'transition-property') {\n        values.forEach(value => {\n          let lookup = this.prefixes.add[value]\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n            isPrefixed = true\n          }\n        })\n        return undefined\n      }\n      // check if another transition-* prop in current Rule has comma separated value list\n      hasAssociatedProp = hasAssociatedProp || values.length > 1\n      return false\n    })\n\n    if (isPrefixed && hasAssociatedProp) {\n      decl.warn(\n        result,\n        'Replace transition-property to transition, ' +\n          'because Autoprefixer could not support ' +\n          'any cases of transition-property ' +\n          'and other transition-*'\n      )\n    }\n  }\n\n  /**\n   * Process transition and remove all unnecessary properties\n   */\n  remove(decl) {\n    let params = this.parse(decl.value)\n    params = params.filter(i => {\n      let prop = this.prefixes.remove[this.findProp(i)]\n      return !prop || !prop.remove\n    })\n    let value = this.stringify(params)\n\n    if (decl.value === value) {\n      return\n    }\n\n    if (params.length === 0) {\n      decl.remove()\n      return\n    }\n\n    let double = decl.parent.some(i => {\n      return i.prop === decl.prop && i.value === value\n    })\n    let smaller = decl.parent.some(i => {\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length\n    })\n\n    if (double || smaller) {\n      decl.remove()\n      return\n    }\n\n    decl.value = value\n  }\n\n  /**\n   * Parse properties list to array\n   */\n  parse(value) {\n    let ast = parser(value)\n    let result = []\n    let param = []\n    for (let node of ast.nodes) {\n      param.push(node)\n      if (node.type === 'div' && node.value === ',') {\n        result.push(param)\n        param = []\n      }\n    }\n    result.push(param)\n    return result.filter(i => i.length > 0)\n  }\n\n  /**\n   * Return properties string from array\n   */\n  stringify(params) {\n    if (params.length === 0) {\n      return ''\n    }\n    let nodes = []\n    for (let param of params) {\n      if (param[param.length - 1].type !== 'div') {\n        param.push(this.div(params))\n      }\n      nodes = nodes.concat(param)\n    }\n    if (nodes[0].type === 'div') {\n      nodes = nodes.slice(1)\n    }\n    if (nodes[nodes.length - 1].type === 'div') {\n      nodes = nodes.slice(0, +-2 + 1 || undefined)\n    }\n    return parser.stringify({ nodes })\n  }\n\n  /**\n   * Return new param array with different name\n   */\n  clone(origin, name, param) {\n    let result = []\n    let changed = false\n    for (let i of param) {\n      if (!changed && i.type === 'word' && i.value === origin) {\n        result.push({ type: 'word', value: name })\n        changed = true\n      } else {\n        result.push(i)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Find or create separator\n   */\n  div(params) {\n    for (let param of params) {\n      for (let node of param) {\n        if (node.type === 'div' && node.value === ',') {\n          return node\n        }\n      }\n    }\n    return { type: 'div', value: ',', after: ' ' }\n  }\n\n  cleanOtherPrefixes(params, prefix) {\n    return params.filter(param => {\n      let current = vendor.prefix(this.findProp(param))\n      return current === '' || current === prefix\n    })\n  }\n\n  /**\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n   */\n  cleanFromUnprefixed(params, prefix) {\n    let remove = params\n      .map(i => this.findProp(i))\n      .filter(i => i.slice(0, prefix.length) === prefix)\n      .map(i => this.prefixes.unprefixed(i))\n\n    let result = []\n    for (let param of params) {\n      let prop = this.findProp(param)\n      let p = vendor.prefix(prop)\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\n        result.push(param)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Check property for disabled by option\n   */\n  disabled(prop, prefix) {\n    let other = ['order', 'justify-content', 'align-self', 'align-content']\n    if (prop.includes('flex') || other.includes(prop)) {\n      if (this.prefixes.options.flexbox === false) {\n        return true\n      }\n\n      if (this.prefixes.options.flexbox === 'no-2009') {\n        return prefix.includes('2009')\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Check if transition prop is inside vendor specific rule\n   */\n  ruleVendorPrefixes(decl) {\n    let { parent } = decl\n\n    if (parent.type !== 'rule') {\n      return false\n    } else if (!parent.selector.includes(':-')) {\n      return false\n    }\n\n    let selectors = Browsers.prefixes().filter(s =>\n      parent.selector.includes(':' + s)\n    )\n\n    return selectors.length > 0 ? selectors : false\n  }\n}\n\nmodule.exports = Transition\n"]},"metadata":{},"sourceType":"script"}