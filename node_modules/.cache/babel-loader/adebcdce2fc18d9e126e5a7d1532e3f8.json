{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar Browsers = require('./browsers');\n\nvar vendor = require('./vendor');\n\nvar utils = require('./utils');\n/**\n * Recursively clone objects\n */\n\n\nfunction _clone(obj, parent) {\n  var cloned = new obj.constructor();\n\n  for (var _i = 0, _Object$keys = Object.keys(obj || {}); _i < _Object$keys.length; _i++) {\n    var i = _Object$keys[_i];\n    var value = obj[i];\n\n    if (i === 'parent' && typeof value === 'object') {\n      if (parent) {\n        cloned[i] = parent;\n      }\n    } else if (i === 'source' || i === null) {\n      cloned[i] = value;\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(function (x) {\n        return _clone(x, cloned);\n      });\n    } else if (i !== '_autoprefixerPrefix' && i !== '_autoprefixerValues' && i !== 'proxyCache') {\n      if (typeof value === 'object' && value !== null) {\n        value = _clone(value, cloned);\n      }\n\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n}\n\nvar Prefixer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Prefixer(name, prefixes, all) {\n    _classCallCheck(this, Prefixer);\n\n    this.prefixes = prefixes;\n    this.name = name;\n    this.all = all;\n  }\n  /**\n   * Find prefix in node parents\n   */\n\n\n  _createClass(Prefixer, [{\n    key: \"parentPrefix\",\n    value: function parentPrefix(node) {\n      var prefix;\n\n      if (typeof node._autoprefixerPrefix !== 'undefined') {\n        prefix = node._autoprefixerPrefix;\n      } else if (node.type === 'decl' && node.prop[0] === '-') {\n        prefix = vendor.prefix(node.prop);\n      } else if (node.type === 'root') {\n        prefix = false;\n      } else if (node.type === 'rule' && node.selector.includes(':-') && /:(-\\w+-)/.test(node.selector)) {\n        prefix = node.selector.match(/:(-\\w+-)/)[1];\n      } else if (node.type === 'atrule' && node.name[0] === '-') {\n        prefix = vendor.prefix(node.name);\n      } else {\n        prefix = this.parentPrefix(node.parent);\n      }\n\n      if (!Browsers.prefixes().includes(prefix)) {\n        prefix = false;\n      }\n\n      node._autoprefixerPrefix = prefix;\n      return node._autoprefixerPrefix;\n    }\n    /**\n     * Clone node with prefixes\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(node, result) {\n      if (!this.check(node)) {\n        return undefined;\n      }\n\n      var parent = this.parentPrefix(node);\n      var prefixes = this.prefixes.filter(function (prefix) {\n        return !parent || parent === utils.removeNote(prefix);\n      });\n      var added = [];\n\n      var _iterator = _createForOfIteratorHelper(prefixes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var prefix = _step.value;\n\n          if (this.add(node, prefix, added.concat([prefix]), result)) {\n            added.push(prefix);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return added;\n    }\n    /**\n     * Shortcut for Prefixer.clone\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(node, overrides) {\n      return Prefixer.clone(node, overrides);\n    }\n  }], [{\n    key: \"hack\",\n    value:\n    /**\n     * Add hack to selected names\n     */\n    function hack(klass) {\n      var _this = this;\n\n      if (!this.hacks) {\n        this.hacks = {};\n      }\n\n      return klass.names.map(function (name) {\n        _this.hacks[name] = klass;\n        return _this.hacks[name];\n      });\n    }\n    /**\n     * Load hacks for some names\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(name, prefixes, all) {\n      var Klass = this.hacks && this.hacks[name];\n\n      if (Klass) {\n        return new Klass(name, prefixes, all);\n      } else {\n        return new this(name, prefixes, all);\n      }\n    }\n    /**\n     * Clone node and clean autprefixer custom caches\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(node, overrides) {\n      var cloned = _clone(node);\n\n      for (var name in overrides) {\n        cloned[name] = overrides[name];\n      }\n\n      return cloned;\n    }\n  }]);\n\n  return Prefixer;\n}();\n\nmodule.exports = Prefixer;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/prefixer.js"],"names":["Browsers","require","vendor","utils","clone","obj","parent","cloned","constructor","Object","keys","i","value","Array","isArray","map","x","Prefixer","name","prefixes","all","node","prefix","_autoprefixerPrefix","type","prop","selector","includes","test","match","parentPrefix","result","check","undefined","filter","removeNote","added","add","concat","push","overrides","klass","hacks","names","Klass","module","exports"],"mappings":"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","sourcesContent":["let Browsers = require('./browsers')\nlet vendor = require('./vendor')\nlet utils = require('./utils')\n\n/**\n * Recursively clone objects\n */\nfunction clone(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i of Object.keys(obj || {})) {\n    let value = obj[i]\n    if (i === 'parent' && typeof value === 'object') {\n      if (parent) {\n        cloned[i] = parent\n      }\n    } else if (i === 'source' || i === null) {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(x => clone(x, cloned))\n    } else if (\n      i !== '_autoprefixerPrefix' &&\n      i !== '_autoprefixerValues' &&\n      i !== 'proxyCache'\n    ) {\n      if (typeof value === 'object' && value !== null) {\n        value = clone(value, cloned)\n      }\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Prefixer {\n  /**\n   * Add hack to selected names\n   */\n  static hack(klass) {\n    if (!this.hacks) {\n      this.hacks = {}\n    }\n    return klass.names.map(name => {\n      this.hacks[name] = klass\n      return this.hacks[name]\n    })\n  }\n\n  /**\n   * Load hacks for some names\n   */\n  static load(name, prefixes, all) {\n    let Klass = this.hacks && this.hacks[name]\n    if (Klass) {\n      return new Klass(name, prefixes, all)\n    } else {\n      return new this(name, prefixes, all)\n    }\n  }\n\n  /**\n   * Clone node and clean autprefixer custom caches\n   */\n  static clone(node, overrides) {\n    let cloned = clone(node)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  constructor(name, prefixes, all) {\n    this.prefixes = prefixes\n    this.name = name\n    this.all = all\n  }\n\n  /**\n   * Find prefix in node parents\n   */\n  parentPrefix(node) {\n    let prefix\n\n    if (typeof node._autoprefixerPrefix !== 'undefined') {\n      prefix = node._autoprefixerPrefix\n    } else if (node.type === 'decl' && node.prop[0] === '-') {\n      prefix = vendor.prefix(node.prop)\n    } else if (node.type === 'root') {\n      prefix = false\n    } else if (\n      node.type === 'rule' &&\n      node.selector.includes(':-') &&\n      /:(-\\w+-)/.test(node.selector)\n    ) {\n      prefix = node.selector.match(/:(-\\w+-)/)[1]\n    } else if (node.type === 'atrule' && node.name[0] === '-') {\n      prefix = vendor.prefix(node.name)\n    } else {\n      prefix = this.parentPrefix(node.parent)\n    }\n\n    if (!Browsers.prefixes().includes(prefix)) {\n      prefix = false\n    }\n\n    node._autoprefixerPrefix = prefix\n\n    return node._autoprefixerPrefix\n  }\n\n  /**\n   * Clone node with prefixes\n   */\n  process(node, result) {\n    if (!this.check(node)) {\n      return undefined\n    }\n\n    let parent = this.parentPrefix(node)\n\n    let prefixes = this.prefixes.filter(\n      prefix => !parent || parent === utils.removeNote(prefix)\n    )\n\n    let added = []\n    for (let prefix of prefixes) {\n      if (this.add(node, prefix, added.concat([prefix]), result)) {\n        added.push(prefix)\n      }\n    }\n\n    return added\n  }\n\n  /**\n   * Shortcut for Prefixer.clone\n   */\n  clone(node, overrides) {\n    return Prefixer.clone(node, overrides)\n  }\n}\n\nmodule.exports = Prefixer\n"]},"metadata":{},"sourceType":"script"}