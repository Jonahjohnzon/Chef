{"ast":null,"code":"var _toConsumableArray = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar parser = require('postcss-value-parser');\n\nvar list = require('postcss').list;\n\nvar uniq = require('../utils').uniq;\n\nvar escapeRegexp = require('../utils').escapeRegexp;\n\nvar splitSelector = require('../utils').splitSelector;\n\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n\n  return [false, false];\n}\n\nexports.translate = translate;\n\nfunction translate(values, startIndex, endIndex) {\n  var startValue = values[startIndex];\n  var endValue = values[endIndex];\n\n  if (!startValue) {\n    return [false, false];\n  }\n\n  var _convert = convert(startValue),\n      _convert2 = _slicedToArray(_convert, 2),\n      start = _convert2[0],\n      spanStart = _convert2[1];\n\n  var _convert3 = convert(endValue),\n      _convert4 = _slicedToArray(_convert3, 2),\n      end = _convert4[0],\n      spanEnd = _convert4[1];\n\n  if (start && !endValue) {\n    return [start, false];\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n\n  if (start && end) {\n    return [start, end - start];\n  }\n\n  return [false, false];\n}\n\nexports.parse = parse;\n\nfunction parse(decl) {\n  var node = parser(decl.value);\n  var values = [];\n  var current = 0;\n  values[current] = [];\n\n  var _iterator = _createForOfIteratorHelper(node.nodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var i = _step.value;\n\n      if (i.type === 'div') {\n        current += 1;\n        values[current] = [];\n      } else if (i.type === 'word') {\n        values[current].push(i.value);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return values;\n}\n\nexports.insertDecl = insertDecl;\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(function (i) {\n    return i.prop === \"-ms-\".concat(prop);\n  })) {\n    decl.cloneBefore({\n      prop: \"-ms-\".concat(prop),\n      value: value.toString()\n    });\n  }\n} // Track transforms\n\n\nexports.prefixTrackProp = prefixTrackProp;\n\nfunction prefixTrackProp(_ref) {\n  var prop = _ref.prop,\n      prefix = _ref.prefix;\n  return prefix + prop.replace('template-', '');\n}\n\nfunction transformRepeat(_ref2, _ref3) {\n  var nodes = _ref2.nodes;\n  var gap = _ref3.gap;\n\n  var _nodes$reduce = nodes.reduce(function (result, node) {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  }),\n      count = _nodes$reduce.count,\n      size = _nodes$reduce.size; // insert gap values\n\n\n  if (gap) {\n    var _ret = function () {\n      size = size.filter(function (i) {\n        return i.trim();\n      });\n      var val = [];\n\n      var _loop = function _loop(i) {\n        size.forEach(function (item, index) {\n          if (index > 0 || i > 1) {\n            val.push(gap);\n          }\n\n          val.push(item);\n        });\n      };\n\n      for (var i = 1; i <= count; i++) {\n        _loop(i);\n      }\n\n      return {\n        v: val.join(' ')\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return \"(\".concat(size.join(''), \")[\").concat(count.join(''), \"]\");\n}\n\nexports.prefixTrackValue = prefixTrackValue;\n\nfunction prefixTrackValue(_ref4) {\n  var value = _ref4.value,\n      gap = _ref4.gap;\n  var result = parser(value).nodes.reduce(function (nodes, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap: gap\n        })\n      });\n    }\n\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n} // Parse grid-template-areas\n\n\nvar DOTS = /^\\.+$/;\n\nfunction track(start, end) {\n  return {\n    start: start,\n    end: end,\n    span: end - start\n  };\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\n\nexports.parseGridAreas = parseGridAreas;\n\nfunction parseGridAreas(_ref5) {\n  var rows = _ref5.rows,\n      gap = _ref5.gap;\n  return rows.reduce(function (areas, line, rowIndex) {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach(function (area, columnIndex) {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        var _areas$area = areas[area],\n            column = _areas$area.column,\n            row = _areas$area.row;\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n} // Parse grid-template\n\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value);\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n\n  return result;\n}\n\nexports.parseTemplate = parseTemplate;\n\nfunction parseTemplate(_ref6) {\n  var decl = _ref6.decl,\n      gap = _ref6.gap;\n  var gridTemplate = parser(decl.value).nodes.reduce(function (result, node) {\n    var type = node.type,\n        value = node.value;\n    if (testTrack(node) || type === 'space') return result; // area\n\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    } // values and function\n\n\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    } // divider(/)\n\n\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap: gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n} // Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\n\n\nfunction getMSDecls(area) {\n  var addRowSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var addColumnSpan = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var result = [{\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }];\n\n  if (area.row.span > 1 || addRowSpan) {\n    result.push({\n      prop: '-ms-grid-row-span',\n      value: String(area.row.span)\n    });\n  }\n\n  result.push({\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  });\n\n  if (area.column.span > 1 || addColumnSpan) {\n    result.push({\n      prop: '-ms-grid-column-span',\n      value: String(area.column.span)\n    });\n  }\n\n  return result;\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n\n  if (!parent.parent) {\n    return false;\n  }\n\n  return getParentMedia(parent.parent);\n}\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\n\n\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(function (selector) {\n    var selectorBySpace = list.space(selector);\n    var selectorByComma = list.comma(selector);\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n\n    return selector;\n  });\n  return ruleSelectors.map(function (ruleSelector) {\n    var newSelector = templateSelectors.map(function (tplSelector, index) {\n      var space = index === 0 ? '' : ' ';\n      return \"\".concat(space).concat(tplSelector, \" > \").concat(ruleSelector);\n    });\n    return newSelector;\n  });\n}\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\n\n\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(function (sel) {\n    return ruleB.selectors.includes(sel);\n  });\n}\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\n\n\nfunction parseGridTemplatesData(css) {\n  var parsed = []; // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n\n  css.walkDecls(/grid-template(-areas)?$/, function (d) {\n    var rule = d.parent;\n    var media = getParentMedia(rule);\n    var gap = getGridGap(d);\n    var inheritedGap = inheritGridGap(d, gap);\n\n    var _parseTemplate = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    }),\n        areas = _parseTemplate.areas;\n\n    var areaNames = Object.keys(areas); // skip node if it doesn't have areas\n\n    if (areaNames.length === 0) {\n      return true;\n    } // check parsed array for item that include the same area names\n    // return index of that item\n\n\n    var index = parsed.reduce(function (acc, _ref7, idx) {\n      var allAreas = _ref7.allAreas;\n      var hasAreas = allAreas && areaNames.some(function (area) {\n        return allAreas.includes(area);\n      });\n      return hasAreas ? idx : acc;\n    }, null);\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      var _parsed$index = parsed[index],\n          allAreas = _parsed$index.allAreas,\n          rules = _parsed$index.rules; // check if rule has no duplicate area names\n\n      var hasNoDuplicates = rules.some(function (r) {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      var duplicatesFound = false; // check need to gather all duplicate area names\n\n      var duplicateAreaNames = rules.reduce(function (acc, r) {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n\n        if (!duplicatesFound) {\n          areaNames.forEach(function (name) {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n\n        return uniq(acc);\n      }, []); // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n\n      rules.forEach(function (r) {\n        areaNames.forEach(function (name) {\n          var area = r.areas[name];\n\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([].concat(_toConsumableArray(allAreas), _toConsumableArray(areaNames)));\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames: duplicateAreaNames,\n        areas: areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas: areas\n        }]\n      });\n    }\n\n    return undefined;\n  });\n  return parsed;\n}\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\n\n\nexports.insertAreas = insertAreas;\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  var gridTemplatesData = parseGridTemplatesData(css); // return undefined if no declarations found\n\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  } // we need to store the rules that we will insert later\n\n\n  var rulesToInsert = {};\n  css.walkDecls('grid-area', function (gridArea) {\n    var gridAreaRule = gridArea.parent;\n    var hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    var gridAreaMedia = getParentMedia(gridAreaRule);\n\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n\n    var gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule);\n    var value = gridArea.value; // found the data that matches grid-area identifier\n\n    var data = gridTemplatesData.filter(function (d) {\n      return d.allAreas.includes(value);\n    })[0];\n\n    if (!data) {\n      return true;\n    }\n\n    var lastArea = data.allAreas[data.allAreas.length - 1];\n    var selectorBySpace = list.space(gridAreaRule.selector);\n    var selectorByComma = list.comma(gridAreaRule.selector);\n    var selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length; // prevent doubling of prefixes\n\n    if (hasPrefixedRow) {\n      return false;\n    } // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n\n\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n\n    var lastRuleIsSet = false; // walk through every grid-template rule data\n\n    var _iterator2 = _createForOfIteratorHelper(data.rules),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var rule = _step2.value;\n        var area = rule.areas[value];\n        var hasDuplicateName = rule.duplicateAreaNames.includes(value); // if we can't find the area name, update lastRule and continue\n\n        if (!area) {\n          var lastRule = rulesToInsert[lastArea].lastRule;\n          var lastRuleIndex = void 0;\n\n          if (lastRule) {\n            lastRuleIndex = css.index(lastRule);\n          } else {\n            /* c8 ignore next 2 */\n            lastRuleIndex = -1;\n          }\n\n          if (gridAreaRuleIndex > lastRuleIndex) {\n            rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n          }\n\n          continue;\n        } // for grid-templates inside media rule we need to create empty\n        // array to push prefixed grid-area rules later\n\n\n        if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n          rulesToInsert[lastArea][rule.params] = [];\n        }\n\n        if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n          // grid-template has no duplicates and not inside media rule\n          getMSDecls(area, false, false).reverse().forEach(function (i) {\n            return gridAreaRule.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n          rulesToInsert[lastArea].lastRule = gridAreaRule;\n          lastRuleIsSet = true;\n        } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n          (function () {\n            // grid-template has duplicates and not inside media rule\n            var cloned = gridAreaRule.clone();\n            cloned.removeAll();\n            getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n              return cloned.prepend(Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              }));\n            });\n            cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n\n            if (rulesToInsert[lastArea].lastRule) {\n              rulesToInsert[lastArea].lastRule.after(cloned);\n            }\n\n            rulesToInsert[lastArea].lastRule = cloned;\n            lastRuleIsSet = true;\n          })();\n        } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n          // grid-template has duplicates and not inside media rule\n          // and the selector is complex\n          gridAreaRule.walkDecls(/-ms-grid-(row|column)/, function (d) {\n            return d.remove();\n          });\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return gridAreaRule.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n        } else if (rule.params) {\n          (function () {\n            // grid-template is inside media rule\n            // if we're inside media rule, we need to store prefixed rules\n            // inside rulesToInsert object to be able to preserve the order of media\n            // rules and merge them easily\n            var cloned = gridAreaRule.clone();\n            cloned.removeAll();\n            getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n              return cloned.prepend(Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              }));\n            });\n\n            if (rule.hasDuplicates && hasDuplicateName) {\n              cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n            }\n\n            cloned.raws = rule.node.raws;\n\n            if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n              // append the prefixed rules right inside media rule\n              // with grid-template\n              rule.node.parent.append(cloned);\n            } else {\n              // store the rule to insert later\n              rulesToInsert[lastArea][rule.params].push(cloned);\n            } // set new rule as last rule ONLY if we didn't set lastRule for\n            // this grid-area before\n\n\n            if (!lastRuleIsSet) {\n              rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n            }\n          })();\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return undefined;\n  }); // append stored rules inside the media rules\n\n  Object.keys(rulesToInsert).forEach(function (area) {\n    var data = rulesToInsert[area];\n    var lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(function (p) {\n      return p !== 'lastRule';\n    }).forEach(function (params) {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params: params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nexports.warnMissedAreas = warnMissedAreas;\n\nfunction warnMissedAreas(areas, decl, result) {\n  var missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', function (gridArea) {\n    missed = missed.filter(function (e) {\n      return e !== gridArea.value;\n    });\n  });\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n\n  return undefined;\n}\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nexports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound;\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  var rule = decl.parent;\n  var root = decl.root();\n  var duplicatesFound = false; // slice selector array. Remove the last part (for comparison)\n\n  var slicedSelectorArr = list.space(rule.selector).filter(function (str) {\n    return str !== '>';\n  }).slice(0, -1); // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n\n  if (slicedSelectorArr.length > 0) {\n    var gridTemplateFound = false;\n    var foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, function (d) {\n      var parent = d.parent;\n      var templateSelectors = parent.selectors;\n\n      var _parseTemplate2 = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      }),\n          areas = _parseTemplate2.areas;\n\n      var hasArea = areas[decl.value]; // find the the matching selectors\n\n      var _iterator3 = _createForOfIteratorHelper(templateSelectors),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var tplSelector = _step3.value;\n\n          if (gridTemplateFound) {\n            break;\n          }\n\n          var tplSelectorArr = list.space(tplSelector).filter(function (str) {\n            return str !== '>';\n          });\n          gridTemplateFound = tplSelectorArr.every(function (item, idx) {\n            return item === slicedSelectorArr[idx];\n          });\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      } // if we found the duplicate area with different selector\n\n\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n\n      return undefined;\n    }); // warn user if we didn't find template\n\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, 'Autoprefixer cannot find a grid-template ' + \"containing the duplicate grid-area \\\"\".concat(decl.value, \"\\\" \") + \"with full selector matching: \".concat(slicedSelectorArr.join(' ')));\n    }\n  }\n}\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nexports.warnIfGridRowColumnExists = warnIfGridRowColumnExists;\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  var rule = decl.parent;\n  var decls = [];\n  rule.walkDecls(/^grid-(row|column)/, function (d) {\n    if (!d.prop.endsWith('-end') && !d.value.startsWith('span') && !d.prop.endsWith('-gap')) {\n      decls.push(d);\n    }\n  });\n\n  if (decls.length > 0) {\n    decls.forEach(function (d) {\n      d.warn(result, 'You already have a grid-area declaration present in the rule. ' + \"You should use either grid-area or \".concat(d.prop, \", not both\"));\n    });\n  }\n\n  return undefined;\n} // Gap utils\n\n\nexports.getGridGap = getGridGap;\n\nfunction getGridGap(decl) {\n  var gap = {}; // try to find gap\n\n  var testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, function (_ref8) {\n    var prop = _ref8.prop,\n        value = _ref8.value;\n\n    if (/^(grid-)?gap$/.test(prop)) {\n      var _parser$nodes = _slicedToArray(parser(value).nodes, 3),\n          row = _parser$nodes[0],\n          column = _parser$nodes[2];\n\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\n\n\nfunction parseMediaParams(params) {\n  if (!params) {\n    return [];\n  }\n\n  var parsed = parser(params);\n  var prop;\n  var value;\n  parsed.walk(function (node) {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\n\n\nfunction shouldInheritGap(selA, selB) {\n  var result; // get arrays of selector split in 3-deep array\n\n  var splitSelectorArrA = splitSelector(selA);\n  var splitSelectorArrB = splitSelector(selB);\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n    var idx = splitSelectorArrA[0].reduce(function (res, _ref9, index) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          item = _ref10[0];\n\n      var firstSelectorPart = splitSelectorArrB[0][0][0];\n\n      if (item === firstSelectorPart) {\n        return index;\n      }\n\n      return false;\n    }, false);\n\n    if (idx) {\n      result = splitSelectorArrB[0].every(function (arr, index) {\n        return arr.every(function (part, innerIndex) {\n          return (// because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n          );\n        });\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(function (byCommaArr) {\n      return byCommaArr.every(function (bySpaceArr, index) {\n        return bySpaceArr.every(function (part, innerIndex) {\n          return splitSelectorArrA[0][index][innerIndex] === part;\n        });\n      });\n    });\n  }\n\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\n\n\nexports.inheritGridGap = inheritGridGap;\n\nfunction inheritGridGap(decl, gap) {\n  var rule = decl.parent;\n  var mediaRule = getParentMedia(rule);\n  var root = rule.root(); // get an array of selector split in 3-deep array\n\n  var splitSelectorArr = splitSelector(rule.selector); // abort if the rule already has gaps\n\n  if (Object.keys(gap).length > 0) {\n    return false;\n  } // e.g ['min-width']\n\n\n  var _parseMediaParams = parseMediaParams(mediaRule.params),\n      _parseMediaParams2 = _slicedToArray(_parseMediaParams, 1),\n      prop = _parseMediaParams2[0];\n\n  var lastBySpace = splitSelectorArr[0]; // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n\n  var escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  var regexp = new RegExp(\"(\".concat(escaped, \"$)|(\").concat(escaped, \"[,.])\")); // find the closest rule with the same selector\n\n  var closestRuleGap;\n  root.walkRules(regexp, function (r) {\n    var gridGap; // abort if are checking the same rule\n\n    if (rule.toString() === r.toString()) {\n      return false;\n    } // find grid-gap values\n\n\n    r.walkDecls('grid-gap', function (d) {\n      return gridGap = getGridGap(d);\n    }); // skip rule without gaps\n\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    } // skip rules that should not be inherited from\n\n\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n\n    var media = getParentMedia(r);\n\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      var propToCompare = parseMediaParams(media.params)[0];\n\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n\n    return undefined;\n  }); // if we find the closest gap object\n\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n\n  return false;\n}\n\nexports.warnGridGap = warnGridGap;\n\nfunction warnGridGap(_ref11) {\n  var gap = _ref11.gap,\n      hasColumns = _ref11.hasColumns,\n      decl = _ref11.decl,\n      result = _ref11.result;\n  var hasBothGaps = gap.row && gap.column;\n\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\n\n\nfunction normalizeRowColumn(str) {\n  var normalized = parser(str).nodes.reduce(function (result, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      var key = 'count';\n\n      var _node$nodes$reduce = node.nodes.reduce(function (acc, n) {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n\n        return acc;\n      }, [0, '']),\n          _node$nodes$reduce2 = _slicedToArray(_node$nodes$reduce, 2),\n          count = _node$nodes$reduce2[0],\n          value = _node$nodes$reduce2[1];\n\n      if (count) {\n        for (var i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n\n      return result;\n    }\n\n    if (node.type === 'space') {\n      return result;\n    }\n\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\n\nexports.autoplaceGridItems = autoplaceGridItems;\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\n\nfunction autoplaceGridItems(decl, result, gap) {\n  var autoflowValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'row';\n  var parent = decl.parent;\n  var rowDecl = parent.nodes.find(function (i) {\n    return i.prop === 'grid-template-rows';\n  });\n  var rows = normalizeRowColumn(rowDecl.value);\n  var columns = normalizeRowColumn(decl.value); // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n\n  var filledRows = rows.map(function (_, rowIndex) {\n    return Array.from({\n      length: columns.length\n    }, function (v, k) {\n      return k + rowIndex * columns.length + 1;\n    }).join(' ');\n  });\n  var areas = parseGridAreas({\n    rows: filledRows,\n    gap: gap\n  });\n  var keys = Object.keys(areas);\n  var items = keys.map(function (i) {\n    return areas[i];\n  }); // Change the order of cells if grid-auto-flow value is 'column'\n\n  if (autoflowValue.includes('column')) {\n    items = items.sort(function (a, b) {\n      return a.column.start - b.column.start;\n    });\n  } // Insert new rules\n\n\n  items.reverse().forEach(function (item, index) {\n    var column = item.column,\n        row = item.row;\n    var nodeSelector = parent.selectors.map(function (sel) {\n      return sel + \" > *:nth-child(\".concat(keys.length - index, \")\");\n    }).join(', '); // create new rule\n\n    var node = parent.clone().removeAll(); // change rule selector\n\n    node.selector = nodeSelector; // insert prefixed row/column values\n\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    }); // insert rule\n\n    parent.after(node);\n  });\n  return undefined;\n}","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/hacks/grid-utils.js"],"names":["parser","require","list","uniq","escapeRegexp","splitSelector","convert","value","length","parseInt","exports","translate","values","startIndex","endIndex","startValue","endValue","start","spanStart","end","spanEnd","parse","decl","node","current","nodes","i","type","push","insertDecl","prop","parent","some","cloneBefore","toString","prefixTrackProp","prefix","replace","transformRepeat","gap","reduce","result","key","stringify","size","count","filter","trim","val","forEach","item","index","join","prefixTrackValue","concat","DOTS","track","span","getColumns","line","split","parseGridAreas","rows","areas","rowIndex","row","area","columnIndex","test","column","Math","min","max","testTrack","verifyRowSize","parseTemplate","gridTemplate","columns","getMSDecls","addRowSpan","addColumnSpan","String","getParentMedia","name","changeDuplicateAreaSelectors","ruleSelectors","templateSelectors","map","selector","selectorBySpace","space","selectorByComma","comma","slice","ruleSelector","newSelector","tplSelector","selectorsEqual","ruleA","ruleB","selectors","sel","includes","parseGridTemplatesData","css","parsed","walkDecls","d","rule","media","getGridGap","inheritedGap","inheritGridGap","areaNames","Object","keys","acc","idx","allAreas","hasAreas","rules","hasNoDuplicates","r","hasDuplicates","duplicatesFound","duplicateAreaNames","params","updateSpan","areasCount","duplicateRules","undefined","insertAreas","isDisabled","gridTemplatesData","rulesToInsert","gridArea","gridAreaRule","hasPrefixedRow","first","gridAreaMedia","gridAreaRuleIndex","data","lastArea","selectorIsComplex","lastRuleIsSet","hasDuplicateName","lastRule","lastRuleIndex","reverse","prepend","assign","raws","between","cloned","clone","removeAll","after","remove","append","p","next","warnMissedAreas","missed","root","e","warn","warnTemplateSelectorNotFound","slicedSelectorArr","str","gridTemplateFound","foundAreaSelector","hasArea","tplSelectorArr","every","warnIfGridRowColumnExists","decls","endsWith","startsWith","testGap","parseMediaParams","walk","shouldInheritGap","selA","selB","splitSelectorArrA","splitSelectorArrB","res","firstSelectorPart","arr","part","innerIndex","byCommaArr","bySpaceArr","mediaRule","splitSelectorArr","lastBySpace","escaped","regexp","RegExp","closestRuleGap","walkRules","gridGap","propToCompare","warnGridGap","hasColumns","hasBothGaps","normalizeRowColumn","normalized","n","abs","autoplaceGridItems","autoflowValue","rowDecl","find","filledRows","_","Array","from","v","k","items","sort","a","b","nodeSelector"],"mappings":";;;;;;AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,IAA9B;;AAEA,IAAIC,IAAI,GAAGF,OAAO,CAAC,UAAD,CAAP,CAAoBE,IAA/B;;AACA,IAAIC,YAAY,GAAGH,OAAO,CAAC,UAAD,CAAP,CAAoBG,YAAvC;;AACA,IAAIC,aAAa,GAAGJ,OAAO,CAAC,UAAD,CAAP,CAAoBI,aAAxC;;AAEA,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,MACEA,KAAK,IACLA,KAAK,CAACC,MAAN,KAAiB,CADjB,IAEAD,KAAK,CAAC,CAAD,CAAL,KAAa,MAFb,IAGAE,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAR,GAAyB,CAJ3B,EAKE;AACA,WAAO,CAAC,KAAD,EAAQE,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAhB,CAAP;AACD;;AAED,MAAIA,KAAK,IAAIA,KAAK,CAACC,MAAN,KAAiB,CAA1B,IAA+BC,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAR,GAAyB,CAA5D,EAA+D;AAC7D,WAAO,CAACE,QAAQ,CAACF,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAT,EAAyB,KAAzB,CAAP;AACD;;AAED,SAAO,CAAC,KAAD,EAAQ,KAAR,CAAP;AACD;;AAEDG,OAAO,CAACC,SAAR,GAAoBA,SAApB;;AAEA,SAASA,SAAT,CAAmBC,MAAnB,EAA2BC,UAA3B,EAAuCC,QAAvC,EAAiD;AAC/C,MAAIC,UAAU,GAAGH,MAAM,CAACC,UAAD,CAAvB;AACA,MAAIG,QAAQ,GAAGJ,MAAM,CAACE,QAAD,CAArB;;AAEA,MAAI,CAACC,UAAL,EAAiB;AACf,WAAO,CAAC,KAAD,EAAQ,KAAR,CAAP;AACD;;AAED,iBAAyBT,OAAO,CAACS,UAAD,CAAhC;AAAA;AAAA,MAAKE,KAAL;AAAA,MAAYC,SAAZ;;AACA,kBAAqBZ,OAAO,CAACU,QAAD,CAA5B;AAAA;AAAA,MAAKG,GAAL;AAAA,MAAUC,OAAV;;AAEA,MAAIH,KAAK,IAAI,CAACD,QAAd,EAAwB;AACtB,WAAO,CAACC,KAAD,EAAQ,KAAR,CAAP;AACD;;AAED,MAAIC,SAAS,IAAIC,GAAjB,EAAsB;AACpB,WAAO,CAACA,GAAG,GAAGD,SAAP,EAAkBA,SAAlB,CAAP;AACD;;AAED,MAAID,KAAK,IAAIG,OAAb,EAAsB;AACpB,WAAO,CAACH,KAAD,EAAQG,OAAR,CAAP;AACD;;AAED,MAAIH,KAAK,IAAIE,GAAb,EAAkB;AAChB,WAAO,CAACF,KAAD,EAAQE,GAAG,GAAGF,KAAd,CAAP;AACD;;AAED,SAAO,CAAC,KAAD,EAAQ,KAAR,CAAP;AACD;;AAEDP,OAAO,CAACW,KAAR,GAAgBA,KAAhB;;AAEA,SAASA,KAAT,CAAeC,IAAf,EAAqB;AACnB,MAAIC,IAAI,GAAGvB,MAAM,CAACsB,IAAI,CAACf,KAAN,CAAjB;AAEA,MAAIK,MAAM,GAAG,EAAb;AACA,MAAIY,OAAO,GAAG,CAAd;AACAZ,EAAAA,MAAM,CAACY,OAAD,CAAN,GAAkB,EAAlB;;AALmB,6CAOLD,IAAI,CAACE,KAPA;AAAA;;AAAA;AAOnB,wDAA0B;AAAA,UAAjBC,CAAiB;;AACxB,UAAIA,CAAC,CAACC,IAAF,KAAW,KAAf,EAAsB;AACpBH,QAAAA,OAAO,IAAI,CAAX;AACAZ,QAAAA,MAAM,CAACY,OAAD,CAAN,GAAkB,EAAlB;AACD,OAHD,MAGO,IAAIE,CAAC,CAACC,IAAF,KAAW,MAAf,EAAuB;AAC5Bf,QAAAA,MAAM,CAACY,OAAD,CAAN,CAAgBI,IAAhB,CAAqBF,CAAC,CAACnB,KAAvB;AACD;AACF;AAdkB;AAAA;AAAA;AAAA;AAAA;;AAgBnB,SAAOK,MAAP;AACD;;AAEDF,OAAO,CAACmB,UAAR,GAAqBA,UAArB;;AAEA,SAASA,UAAT,CAAoBP,IAApB,EAA0BQ,IAA1B,EAAgCvB,KAAhC,EAAuC;AACrC,MAAIA,KAAK,IAAI,CAACe,IAAI,CAACS,MAAL,CAAYC,IAAZ,CAAiB,UAAAN,CAAC;AAAA,WAAIA,CAAC,CAACI,IAAF,mBAAkBA,IAAlB,CAAJ;AAAA,GAAlB,CAAd,EAA+D;AAC7DR,IAAAA,IAAI,CAACW,WAAL,CAAiB;AACfH,MAAAA,IAAI,gBAASA,IAAT,CADW;AAEfvB,MAAAA,KAAK,EAAEA,KAAK,CAAC2B,QAAN;AAFQ,KAAjB;AAID;AACF,C,CAED;;;AAEAxB,OAAO,CAACyB,eAAR,GAA0BA,eAA1B;;AAEA,SAASA,eAAT,OAA2C;AAAA,MAAhBL,IAAgB,QAAhBA,IAAgB;AAAA,MAAVM,MAAU,QAAVA,MAAU;AACzC,SAAOA,MAAM,GAAGN,IAAI,CAACO,OAAL,CAAa,WAAb,EAA0B,EAA1B,CAAhB;AACD;;AAED,SAASC,eAAT,eAA6C;AAAA,MAAlBb,KAAkB,SAAlBA,KAAkB;AAAA,MAAPc,GAAO,SAAPA,GAAO;;AAC3C,sBAAsBd,KAAK,CAACe,MAAN,CACpB,UAACC,MAAD,EAASlB,IAAT,EAAkB;AAChB,QAAIA,IAAI,CAACI,IAAL,KAAc,KAAd,IAAuBJ,IAAI,CAAChB,KAAL,KAAe,GAA1C,EAA+C;AAC7CkC,MAAAA,MAAM,CAACC,GAAP,GAAa,MAAb;AACD,KAFD,MAEO;AACLD,MAAAA,MAAM,CAACA,MAAM,CAACC,GAAR,CAAN,CAAmBd,IAAnB,CAAwB5B,MAAM,CAAC2C,SAAP,CAAiBpB,IAAjB,CAAxB;AACD;;AACD,WAAOkB,MAAP;AACD,GARmB,EASpB;AACEC,IAAAA,GAAG,EAAE,OADP;AAEEE,IAAAA,IAAI,EAAE,EAFR;AAGEC,IAAAA,KAAK,EAAE;AAHT,GAToB,CAAtB;AAAA,MAAMA,KAAN,iBAAMA,KAAN;AAAA,MAAaD,IAAb,iBAAaA,IAAb,CAD2C,CAiB3C;;;AACA,MAAIL,GAAJ,EAAS;AAAA;AACPK,MAAAA,IAAI,GAAGA,IAAI,CAACE,MAAL,CAAY,UAAApB,CAAC;AAAA,eAAIA,CAAC,CAACqB,IAAF,EAAJ;AAAA,OAAb,CAAP;AACA,UAAIC,GAAG,GAAG,EAAV;;AAFO,iCAGEtB,CAHF;AAILkB,QAAAA,IAAI,CAACK,OAAL,CAAa,UAACC,IAAD,EAAOC,KAAP,EAAiB;AAC5B,cAAIA,KAAK,GAAG,CAAR,IAAazB,CAAC,GAAG,CAArB,EAAwB;AACtBsB,YAAAA,GAAG,CAACpB,IAAJ,CAASW,GAAT;AACD;;AACDS,UAAAA,GAAG,CAACpB,IAAJ,CAASsB,IAAT;AACD,SALD;AAJK;;AAGP,WAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAImB,KAArB,EAA4BnB,CAAC,EAA7B,EAAiC;AAAA,cAAxBA,CAAwB;AAOhC;;AAED;AAAA,WAAOsB,GAAG,CAACI,IAAJ,CAAS,GAAT;AAAP;AAZO;;AAAA;AAaR;;AAED,oBAAWR,IAAI,CAACQ,IAAL,CAAU,EAAV,CAAX,eAA6BP,KAAK,CAACO,IAAN,CAAW,EAAX,CAA7B;AACD;;AAED1C,OAAO,CAAC2C,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASA,gBAAT,QAA0C;AAAA,MAAd9C,KAAc,SAAdA,KAAc;AAAA,MAAPgC,GAAO,SAAPA,GAAO;AACxC,MAAIE,MAAM,GAAGzC,MAAM,CAACO,KAAD,CAAN,CAAckB,KAAd,CAAoBe,MAApB,CAA2B,UAACf,KAAD,EAAQF,IAAR,EAAiB;AACvD,QAAIA,IAAI,CAACI,IAAL,KAAc,UAAd,IAA4BJ,IAAI,CAAChB,KAAL,KAAe,QAA/C,EAAyD;AACvD,aAAOkB,KAAK,CAAC6B,MAAN,CAAa;AAClB3B,QAAAA,IAAI,EAAE,MADY;AAElBpB,QAAAA,KAAK,EAAE+B,eAAe,CAACf,IAAD,EAAO;AAAEgB,UAAAA,GAAG,EAAHA;AAAF,SAAP;AAFJ,OAAb,CAAP;AAID;;AACD,QAAIA,GAAG,IAAIhB,IAAI,CAACI,IAAL,KAAc,OAAzB,EAAkC;AAChC,aAAOF,KAAK,CAAC6B,MAAN,CACL;AACE3B,QAAAA,IAAI,EAAE,OADR;AAEEpB,QAAAA,KAAK,EAAE;AAFT,OADK,EAKL;AACEoB,QAAAA,IAAI,EAAE,MADR;AAEEpB,QAAAA,KAAK,EAAEgC;AAFT,OALK,EASLhB,IATK,CAAP;AAWD;;AACD,WAAOE,KAAK,CAAC6B,MAAN,CAAa/B,IAAb,CAAP;AACD,GArBY,EAqBV,EArBU,CAAb;AAuBA,SAAOvB,MAAM,CAAC2C,SAAP,CAAiBF,MAAjB,CAAP;AACD,C,CAED;;;AAEA,IAAIc,IAAI,GAAG,OAAX;;AAEA,SAASC,KAAT,CAAevC,KAAf,EAAsBE,GAAtB,EAA2B;AACzB,SAAO;AAAEF,IAAAA,KAAK,EAALA,KAAF;AAASE,IAAAA,GAAG,EAAHA,GAAT;AAAcsC,IAAAA,IAAI,EAAEtC,GAAG,GAAGF;AAA1B,GAAP;AACD;;AAED,SAASyC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,IAAI,CAACZ,IAAL,GAAYa,KAAZ,CAAkB,MAAlB,CAAP;AACD;;AAEDlD,OAAO,CAACmD,cAAR,GAAyBA,cAAzB;;AAEA,SAASA,cAAT,QAAuC;AAAA,MAAbC,IAAa,SAAbA,IAAa;AAAA,MAAPvB,GAAO,SAAPA,GAAO;AACrC,SAAOuB,IAAI,CAACtB,MAAL,CAAY,UAACuB,KAAD,EAAQJ,IAAR,EAAcK,QAAd,EAA2B;AAC5C,QAAIzB,GAAG,CAAC0B,GAAR,EAAaD,QAAQ,IAAI,CAAZ;AAEb,QAAIL,IAAI,CAACZ,IAAL,OAAgB,EAApB,EAAwB,OAAOgB,KAAP;AAExBL,IAAAA,UAAU,CAACC,IAAD,CAAV,CAAiBV,OAAjB,CAAyB,UAACiB,IAAD,EAAOC,WAAP,EAAuB;AAC9C,UAAIZ,IAAI,CAACa,IAAL,CAAUF,IAAV,CAAJ,EAAqB;AAErB,UAAI3B,GAAG,CAAC8B,MAAR,EAAgBF,WAAW,IAAI,CAAf;;AAEhB,UAAI,OAAOJ,KAAK,CAACG,IAAD,CAAZ,KAAuB,WAA3B,EAAwC;AACtCH,QAAAA,KAAK,CAACG,IAAD,CAAL,GAAc;AACZG,UAAAA,MAAM,EAAEb,KAAK,CAACW,WAAW,GAAG,CAAf,EAAkBA,WAAW,GAAG,CAAhC,CADD;AAEZF,UAAAA,GAAG,EAAET,KAAK,CAACQ,QAAQ,GAAG,CAAZ,EAAeA,QAAQ,GAAG,CAA1B;AAFE,SAAd;AAID,OALD,MAKO;AACL,0BAAsBD,KAAK,CAACG,IAAD,CAA3B;AAAA,YAAMG,MAAN,eAAMA,MAAN;AAAA,YAAcJ,GAAd,eAAcA,GAAd;AAEAI,QAAAA,MAAM,CAACpD,KAAP,GAAeqD,IAAI,CAACC,GAAL,CAASF,MAAM,CAACpD,KAAhB,EAAuBkD,WAAW,GAAG,CAArC,CAAf;AACAE,QAAAA,MAAM,CAAClD,GAAP,GAAamD,IAAI,CAACE,GAAL,CAASH,MAAM,CAAClD,GAAhB,EAAqBgD,WAAW,GAAG,CAAnC,CAAb;AACAE,QAAAA,MAAM,CAACZ,IAAP,GAAcY,MAAM,CAAClD,GAAP,GAAakD,MAAM,CAACpD,KAAlC;AAEAgD,QAAAA,GAAG,CAAChD,KAAJ,GAAYqD,IAAI,CAACC,GAAL,CAASN,GAAG,CAAChD,KAAb,EAAoB+C,QAAQ,GAAG,CAA/B,CAAZ;AACAC,QAAAA,GAAG,CAAC9C,GAAJ,GAAUmD,IAAI,CAACE,GAAL,CAASP,GAAG,CAAC9C,GAAb,EAAkB6C,QAAQ,GAAG,CAA7B,CAAV;AACAC,QAAAA,GAAG,CAACR,IAAJ,GAAWQ,GAAG,CAAC9C,GAAJ,GAAU8C,GAAG,CAAChD,KAAzB;AACD;AACF,KArBD;AAuBA,WAAO8C,KAAP;AACD,GA7BM,EA6BJ,EA7BI,CAAP;AA8BD,C,CAED;;;AAEA,SAASU,SAAT,CAAmBlD,IAAnB,EAAyB;AACvB,SAAOA,IAAI,CAACI,IAAL,KAAc,MAAd,IAAwB,UAAUyC,IAAV,CAAe7C,IAAI,CAAChB,KAApB,CAA/B;AACD;;AAED,SAASmE,aAAT,CAAuBjC,MAAvB,EAA+B;AAC7B,MAAIA,MAAM,CAACsB,KAAP,CAAavD,MAAb,GAAsBiC,MAAM,CAACqB,IAAP,CAAYtD,MAAtC,EAA8C;AAC5CiC,IAAAA,MAAM,CAACqB,IAAP,CAAYlC,IAAZ,CAAiB,MAAjB;AACD;;AACD,SAAOa,MAAP;AACD;;AAED/B,OAAO,CAACiE,aAAR,GAAwBA,aAAxB;;AAEA,SAASA,aAAT,QAAsC;AAAA,MAAbrD,IAAa,SAAbA,IAAa;AAAA,MAAPiB,GAAO,SAAPA,GAAO;AACpC,MAAIqC,YAAY,GAAG5E,MAAM,CAACsB,IAAI,CAACf,KAAN,CAAN,CAAmBkB,KAAnB,CAAyBe,MAAzB,CACjB,UAACC,MAAD,EAASlB,IAAT,EAAkB;AAChB,QAAMI,IAAN,GAAsBJ,IAAtB,CAAMI,IAAN;AAAA,QAAYpB,KAAZ,GAAsBgB,IAAtB,CAAYhB,KAAZ;AAEA,QAAIkE,SAAS,CAAClD,IAAD,CAAT,IAAmBI,IAAI,KAAK,OAAhC,EAAyC,OAAOc,MAAP,CAHzB,CAKhB;;AACA,QAAId,IAAI,KAAK,QAAb,EAAuB;AACrBc,MAAAA,MAAM,GAAGiC,aAAa,CAACjC,MAAD,CAAtB;AACAA,MAAAA,MAAM,CAACsB,KAAP,CAAanC,IAAb,CAAkBrB,KAAlB;AACD,KATe,CAWhB;;;AACA,QAAIoB,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,UAAhC,EAA4C;AAC1Cc,MAAAA,MAAM,CAACA,MAAM,CAACC,GAAR,CAAN,CAAmBd,IAAnB,CAAwB5B,MAAM,CAAC2C,SAAP,CAAiBpB,IAAjB,CAAxB;AACD,KAde,CAgBhB;;;AACA,QAAII,IAAI,KAAK,KAAT,IAAkBpB,KAAK,KAAK,GAAhC,EAAqC;AACnCkC,MAAAA,MAAM,CAACC,GAAP,GAAa,SAAb;AACAD,MAAAA,MAAM,GAAGiC,aAAa,CAACjC,MAAD,CAAtB;AACD;;AAED,WAAOA,MAAP;AACD,GAxBgB,EAyBjB;AACEC,IAAAA,GAAG,EAAE,MADP;AAEEmC,IAAAA,OAAO,EAAE,EAFX;AAGEf,IAAAA,IAAI,EAAE,EAHR;AAIEC,IAAAA,KAAK,EAAE;AAJT,GAzBiB,CAAnB;AAiCA,SAAO;AACLA,IAAAA,KAAK,EAAEF,cAAc,CAAC;AACpBC,MAAAA,IAAI,EAAEc,YAAY,CAACb,KADC;AAEpBxB,MAAAA,GAAG,EAAHA;AAFoB,KAAD,CADhB;AAKLsC,IAAAA,OAAO,EAAExB,gBAAgB,CAAC;AACxB9C,MAAAA,KAAK,EAAEqE,YAAY,CAACC,OAAb,CAAqBzB,IAArB,CAA0B,GAA1B,CADiB;AAExBb,MAAAA,GAAG,EAAEA,GAAG,CAAC8B;AAFe,KAAD,CALpB;AASLP,IAAAA,IAAI,EAAET,gBAAgB,CAAC;AACrB9C,MAAAA,KAAK,EAAEqE,YAAY,CAACd,IAAb,CAAkBV,IAAlB,CAAuB,GAAvB,CADc;AAErBb,MAAAA,GAAG,EAAEA,GAAG,CAAC0B;AAFY,KAAD;AATjB,GAAP;AAcD,C,CAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,UAAT,CAAoBZ,IAApB,EAAqE;AAAA,MAA3Ca,UAA2C,uEAA9B,KAA8B;AAAA,MAAvBC,aAAuB,uEAAP,KAAO;AACnE,MAAIvC,MAAM,GAAG,CACX;AACEX,IAAAA,IAAI,EAAE,cADR;AAEEvB,IAAAA,KAAK,EAAE0E,MAAM,CAACf,IAAI,CAACD,GAAL,CAAShD,KAAV;AAFf,GADW,CAAb;;AAMA,MAAIiD,IAAI,CAACD,GAAL,CAASR,IAAT,GAAgB,CAAhB,IAAqBsB,UAAzB,EAAqC;AACnCtC,IAAAA,MAAM,CAACb,IAAP,CAAY;AACVE,MAAAA,IAAI,EAAE,mBADI;AAEVvB,MAAAA,KAAK,EAAE0E,MAAM,CAACf,IAAI,CAACD,GAAL,CAASR,IAAV;AAFH,KAAZ;AAID;;AACDhB,EAAAA,MAAM,CAACb,IAAP,CAAY;AACVE,IAAAA,IAAI,EAAE,iBADI;AAEVvB,IAAAA,KAAK,EAAE0E,MAAM,CAACf,IAAI,CAACG,MAAL,CAAYpD,KAAb;AAFH,GAAZ;;AAIA,MAAIiD,IAAI,CAACG,MAAL,CAAYZ,IAAZ,GAAmB,CAAnB,IAAwBuB,aAA5B,EAA2C;AACzCvC,IAAAA,MAAM,CAACb,IAAP,CAAY;AACVE,MAAAA,IAAI,EAAE,sBADI;AAEVvB,MAAAA,KAAK,EAAE0E,MAAM,CAACf,IAAI,CAACG,MAAL,CAAYZ,IAAb;AAFH,KAAZ;AAID;;AACD,SAAOhB,MAAP;AACD;;AAED,SAASyC,cAAT,CAAwBnD,MAAxB,EAAgC;AAC9B,MAAIA,MAAM,CAACJ,IAAP,KAAgB,QAAhB,IAA4BI,MAAM,CAACoD,IAAP,KAAgB,OAAhD,EAAyD;AACvD,WAAOpD,MAAP;AACD;;AACD,MAAI,CAACA,MAAM,CAACA,MAAZ,EAAoB;AAClB,WAAO,KAAP;AACD;;AACD,SAAOmD,cAAc,CAACnD,MAAM,CAACA,MAAR,CAArB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqD,4BAAT,CAAsCC,aAAtC,EAAqDC,iBAArD,EAAwE;AACtED,EAAAA,aAAa,GAAGA,aAAa,CAACE,GAAd,CAAkB,UAAAC,QAAQ,EAAI;AAC5C,QAAIC,eAAe,GAAGvF,IAAI,CAACwF,KAAL,CAAWF,QAAX,CAAtB;AACA,QAAIG,eAAe,GAAGzF,IAAI,CAAC0F,KAAL,CAAWJ,QAAX,CAAtB;;AAEA,QAAIC,eAAe,CAACjF,MAAhB,GAAyBmF,eAAe,CAACnF,MAA7C,EAAqD;AACnDgF,MAAAA,QAAQ,GAAGC,eAAe,CAACI,KAAhB,CAAsB,CAAC,CAAvB,EAA0BzC,IAA1B,CAA+B,EAA/B,CAAX;AACD;;AACD,WAAOoC,QAAP;AACD,GARe,CAAhB;AAUA,SAAOH,aAAa,CAACE,GAAd,CAAkB,UAAAO,YAAY,EAAI;AACvC,QAAIC,WAAW,GAAGT,iBAAiB,CAACC,GAAlB,CAAsB,UAACS,WAAD,EAAc7C,KAAd,EAAwB;AAC9D,UAAIuC,KAAK,GAAGvC,KAAK,KAAK,CAAV,GAAc,EAAd,GAAmB,GAA/B;AACA,uBAAUuC,KAAV,SAAkBM,WAAlB,gBAAmCF,YAAnC;AACD,KAHiB,CAAlB;AAKA,WAAOC,WAAP;AACD,GAPM,CAAP;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsC;AACpC,SAAOD,KAAK,CAACE,SAAN,CAAgBpE,IAAhB,CAAqB,UAAAqE,GAAG,EAAI;AACjC,WAAOF,KAAK,CAACC,SAAN,CAAgBE,QAAhB,CAAyBD,GAAzB,CAAP;AACD,GAFM,CAAP;AAGD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,sBAAT,CAAgCC,GAAhC,EAAqC;AACnC,MAAIC,MAAM,GAAG,EAAb,CADmC,CAGnC;AACA;;AACAD,EAAAA,GAAG,CAACE,SAAJ,CAAc,yBAAd,EAAyC,UAAAC,CAAC,EAAI;AAC5C,QAAIC,IAAI,GAAGD,CAAC,CAAC5E,MAAb;AACA,QAAI8E,KAAK,GAAG3B,cAAc,CAAC0B,IAAD,CAA1B;AACA,QAAIrE,GAAG,GAAGuE,UAAU,CAACH,CAAD,CAApB;AACA,QAAII,YAAY,GAAGC,cAAc,CAACL,CAAD,EAAIpE,GAAJ,CAAjC;;AACA,yBAAgBoC,aAAa,CAAC;AAAErD,MAAAA,IAAI,EAAEqF,CAAR;AAAWpE,MAAAA,GAAG,EAAEwE,YAAY,IAAIxE;AAAhC,KAAD,CAA7B;AAAA,QAAMwB,KAAN,kBAAMA,KAAN;;AACA,QAAIkD,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYpD,KAAZ,CAAhB,CAN4C,CAQ5C;;AACA,QAAIkD,SAAS,CAACzG,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,aAAO,IAAP;AACD,KAX2C,CAa5C;AACA;;;AACA,QAAI2C,KAAK,GAAGsD,MAAM,CAACjE,MAAP,CAAc,UAAC4E,GAAD,SAAoBC,GAApB,EAA4B;AAAA,UAApBC,QAAoB,SAApBA,QAAoB;AACpD,UAAIC,QAAQ,GAAGD,QAAQ,IAAIL,SAAS,CAACjF,IAAV,CAAe,UAAAkC,IAAI;AAAA,eAAIoD,QAAQ,CAAChB,QAAT,CAAkBpC,IAAlB,CAAJ;AAAA,OAAnB,CAA3B;AACA,aAAOqD,QAAQ,GAAGF,GAAH,GAASD,GAAxB;AACD,KAHW,EAGT,IAHS,CAAZ;;AAKA,QAAIjE,KAAK,KAAK,IAAd,EAAoB;AAClB;AACA,0BAA0BsD,MAAM,CAACtD,KAAD,CAAhC;AAAA,UAAMmE,QAAN,iBAAMA,QAAN;AAAA,UAAgBE,KAAhB,iBAAgBA,KAAhB,CAFkB,CAIlB;;AACA,UAAIC,eAAe,GAAGD,KAAK,CAACxF,IAAN,CAAW,UAAA0F,CAAC,EAAI;AACpC,eAAOA,CAAC,CAACC,aAAF,KAAoB,KAApB,IAA6B1B,cAAc,CAACyB,CAAD,EAAId,IAAJ,CAAlD;AACD,OAFqB,CAAtB;AAIA,UAAIgB,eAAe,GAAG,KAAtB,CATkB,CAWlB;;AACA,UAAIC,kBAAkB,GAAGL,KAAK,CAAChF,MAAN,CAAa,UAAC4E,GAAD,EAAMM,CAAN,EAAY;AAChD,YAAI,CAACA,CAAC,CAACI,MAAH,IAAa7B,cAAc,CAACyB,CAAD,EAAId,IAAJ,CAA/B,EAA0C;AACxCgB,UAAAA,eAAe,GAAG,IAAlB;AACA,iBAAOF,CAAC,CAACG,kBAAT;AACD;;AACD,YAAI,CAACD,eAAL,EAAsB;AACpBX,UAAAA,SAAS,CAAChE,OAAV,CAAkB,UAAAkC,IAAI,EAAI;AACxB,gBAAIuC,CAAC,CAAC3D,KAAF,CAAQoB,IAAR,CAAJ,EAAmB;AACjBiC,cAAAA,GAAG,CAACxF,IAAJ,CAASuD,IAAT;AACD;AACF,WAJD;AAKD;;AACD,eAAOhF,IAAI,CAACiH,GAAD,CAAX;AACD,OAbwB,EAatB,EAbsB,CAAzB,CAZkB,CA2BlB;AACA;;AACAI,MAAAA,KAAK,CAACvE,OAAN,CAAc,UAAAyE,CAAC,EAAI;AACjBT,QAAAA,SAAS,CAAChE,OAAV,CAAkB,UAAAkC,IAAI,EAAI;AACxB,cAAIjB,IAAI,GAAGwD,CAAC,CAAC3D,KAAF,CAAQoB,IAAR,CAAX;;AACA,cAAIjB,IAAI,IAAIA,IAAI,CAACD,GAAL,CAASR,IAAT,KAAkBM,KAAK,CAACoB,IAAD,CAAL,CAAYlB,GAAZ,CAAgBR,IAA9C,EAAoD;AAClDM,YAAAA,KAAK,CAACoB,IAAD,CAAL,CAAYlB,GAAZ,CAAgB8D,UAAhB,GAA6B,IAA7B;AACD;;AAED,cAAI7D,IAAI,IAAIA,IAAI,CAACG,MAAL,CAAYZ,IAAZ,KAAqBM,KAAK,CAACoB,IAAD,CAAL,CAAYd,MAAZ,CAAmBZ,IAApD,EAA0D;AACxDM,YAAAA,KAAK,CAACoB,IAAD,CAAL,CAAYd,MAAZ,CAAmB0D,UAAnB,GAAgC,IAAhC;AACD;AACF,SATD;AAUD,OAXD;AAaAtB,MAAAA,MAAM,CAACtD,KAAD,CAAN,CAAcmE,QAAd,GAAyBnH,IAAI,8BAAKmH,QAAL,sBAAkBL,SAAlB,GAA7B;AACAR,MAAAA,MAAM,CAACtD,KAAD,CAAN,CAAcqE,KAAd,CAAoB5F,IAApB,CAAyB;AACvB+F,QAAAA,aAAa,EAAE,CAACF,eADO;AAEvBK,QAAAA,MAAM,EAAEjB,KAAK,CAACiB,MAFS;AAGvB1B,QAAAA,SAAS,EAAEQ,IAAI,CAACR,SAHO;AAIvB7E,QAAAA,IAAI,EAAEqF,IAJiB;AAKvBiB,QAAAA,kBAAkB,EAAlBA,kBALuB;AAMvB9D,QAAAA,KAAK,EAALA;AANuB,OAAzB;AAQD,KAnDD,MAmDO;AACL;AACA0C,MAAAA,MAAM,CAAC7E,IAAP,CAAY;AACV0F,QAAAA,QAAQ,EAAEL,SADA;AAEVe,QAAAA,UAAU,EAAE,CAFF;AAGVR,QAAAA,KAAK,EAAE,CACL;AACEG,UAAAA,aAAa,EAAE,KADjB;AAEEM,UAAAA,cAAc,EAAE,EAFlB;AAGEH,UAAAA,MAAM,EAAEjB,KAAK,CAACiB,MAHhB;AAIE1B,UAAAA,SAAS,EAAEQ,IAAI,CAACR,SAJlB;AAKE7E,UAAAA,IAAI,EAAEqF,IALR;AAMEiB,UAAAA,kBAAkB,EAAE,EANtB;AAOE9D,UAAAA,KAAK,EAALA;AAPF,SADK;AAHG,OAAZ;AAeD;;AAED,WAAOmE,SAAP;AACD,GA3FD;AA6FA,SAAOzB,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA/F,OAAO,CAACyH,WAAR,GAAsBA,WAAtB;;AAEA,SAASA,WAAT,CAAqB3B,GAArB,EAA0B4B,UAA1B,EAAsC;AACpC;AACA,MAAIC,iBAAiB,GAAG9B,sBAAsB,CAACC,GAAD,CAA9C,CAFoC,CAIpC;;AACA,MAAI6B,iBAAiB,CAAC7H,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,WAAO0H,SAAP;AACD,GAPmC,CASpC;;;AACA,MAAII,aAAa,GAAG,EAApB;AAEA9B,EAAAA,GAAG,CAACE,SAAJ,CAAc,WAAd,EAA2B,UAAA6B,QAAQ,EAAI;AACrC,QAAIC,YAAY,GAAGD,QAAQ,CAACxG,MAA5B;AACA,QAAI0G,cAAc,GAAGD,YAAY,CAACE,KAAb,CAAmB5G,IAAnB,KAA4B,cAAjD;AACA,QAAI6G,aAAa,GAAGzD,cAAc,CAACsD,YAAD,CAAlC;;AAEA,QAAIJ,UAAU,CAACG,QAAD,CAAd,EAA0B;AACxB,aAAOL,SAAP;AACD;;AAED,QAAIU,iBAAiB,GAAGpC,GAAG,CAACrD,KAAJ,CAAUwF,aAAa,IAAIH,YAA3B,CAAxB;AAEA,QAAIjI,KAAK,GAAGgI,QAAQ,CAAChI,KAArB,CAXqC,CAYrC;;AACA,QAAIsI,IAAI,GAAGR,iBAAiB,CAACvF,MAAlB,CAAyB,UAAA6D,CAAC;AAAA,aAAIA,CAAC,CAACW,QAAF,CAAWhB,QAAX,CAAoB/F,KAApB,CAAJ;AAAA,KAA1B,EAA0D,CAA1D,CAAX;;AAEA,QAAI,CAACsI,IAAL,EAAW;AACT,aAAO,IAAP;AACD;;AAED,QAAIC,QAAQ,GAAGD,IAAI,CAACvB,QAAL,CAAcuB,IAAI,CAACvB,QAAL,CAAc9G,MAAd,GAAuB,CAArC,CAAf;AACA,QAAIiF,eAAe,GAAGvF,IAAI,CAACwF,KAAL,CAAW8C,YAAY,CAAChD,QAAxB,CAAtB;AACA,QAAIG,eAAe,GAAGzF,IAAI,CAAC0F,KAAL,CAAW4C,YAAY,CAAChD,QAAxB,CAAtB;AACA,QAAIuD,iBAAiB,GACnBtD,eAAe,CAACjF,MAAhB,GAAyB,CAAzB,IACAiF,eAAe,CAACjF,MAAhB,GAAyBmF,eAAe,CAACnF,MAF3C,CAtBqC,CA0BrC;;AACA,QAAIiI,cAAJ,EAAoB;AAClB,aAAO,KAAP;AACD,KA7BoC,CA+BrC;AACA;;;AACA,QAAI,CAACH,aAAa,CAACQ,QAAD,CAAlB,EAA8B;AAC5BR,MAAAA,aAAa,CAACQ,QAAD,CAAb,GAA0B,EAA1B;AACD;;AAED,QAAIE,aAAa,GAAG,KAApB,CArCqC,CAuCrC;;AAvCqC,gDAwCpBH,IAAI,CAACrB,KAxCe;AAAA;;AAAA;AAwCrC,6DAA6B;AAAA,YAApBZ,IAAoB;AAC3B,YAAI1C,IAAI,GAAG0C,IAAI,CAAC7C,KAAL,CAAWxD,KAAX,CAAX;AACA,YAAI0I,gBAAgB,GAAGrC,IAAI,CAACiB,kBAAL,CAAwBvB,QAAxB,CAAiC/F,KAAjC,CAAvB,CAF2B,CAI3B;;AACA,YAAI,CAAC2D,IAAL,EAAW;AACT,cAAIgF,QAAQ,GAAGZ,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAvC;AACA,cAAIC,aAAa,SAAjB;;AACA,cAAID,QAAJ,EAAc;AACZC,YAAAA,aAAa,GAAG3C,GAAG,CAACrD,KAAJ,CAAU+F,QAAV,CAAhB;AACD,WAFD,MAEO;AACL;AACAC,YAAAA,aAAa,GAAG,CAAC,CAAjB;AACD;;AAED,cAAIP,iBAAiB,GAAGO,aAAxB,EAAuC;AACrCb,YAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAxB,GAAmCP,aAAa,IAAIH,YAApD;AACD;;AACD;AACD,SAnB0B,CAqB3B;AACA;;;AACA,YAAI5B,IAAI,CAACkB,MAAL,IAAe,CAACQ,aAAa,CAACQ,QAAD,CAAb,CAAwBlC,IAAI,CAACkB,MAA7B,CAApB,EAA0D;AACxDQ,UAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBlC,IAAI,CAACkB,MAA7B,IAAuC,EAAvC;AACD;;AAED,YAAI,CAAC,CAAClB,IAAI,CAACe,aAAN,IAAuB,CAACsB,gBAAzB,KAA8C,CAACrC,IAAI,CAACkB,MAAxD,EAAgE;AAC9D;AAEAhD,UAAAA,UAAU,CAACZ,IAAD,EAAO,KAAP,EAAc,KAAd,CAAV,CACGkF,OADH,GAEGnG,OAFH,CAEW,UAAAvB,CAAC;AAAA,mBACR8G,YAAY,CAACa,OAAb,CACEnC,MAAM,CAACoC,MAAP,CAAc5H,CAAd,EAAiB;AACf6H,cAAAA,IAAI,EAAE;AACJC,gBAAAA,OAAO,EAAEjB,QAAQ,CAACgB,IAAT,CAAcC;AADnB;AADS,aAAjB,CADF,CADQ;AAAA,WAFZ;AAYAlB,UAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAxB,GAAmCV,YAAnC;AACAQ,UAAAA,aAAa,GAAG,IAAhB;AACD,SAjBD,MAiBO,IAAIpC,IAAI,CAACe,aAAL,IAAsB,CAACf,IAAI,CAACkB,MAA5B,IAAsC,CAACiB,iBAA3C,EAA8D;AAAA;AACnE;AACA,gBAAIU,MAAM,GAAGjB,YAAY,CAACkB,KAAb,EAAb;AACAD,YAAAA,MAAM,CAACE,SAAP;AAEA7E,YAAAA,UAAU,CAACZ,IAAD,EAAOA,IAAI,CAACD,GAAL,CAAS8D,UAAhB,EAA4B7D,IAAI,CAACG,MAAL,CAAY0D,UAAxC,CAAV,CACGqB,OADH,GAEGnG,OAFH,CAEW,UAAAvB,CAAC;AAAA,qBACR+H,MAAM,CAACJ,OAAP,CACEnC,MAAM,CAACoC,MAAP,CAAc5H,CAAd,EAAiB;AACf6H,gBAAAA,IAAI,EAAE;AACJC,kBAAAA,OAAO,EAAEjB,QAAQ,CAACgB,IAAT,CAAcC;AADnB;AADS,eAAjB,CADF,CADQ;AAAA,aAFZ;AAYAC,YAAAA,MAAM,CAACrD,SAAP,GAAmBhB,4BAA4B,CAC7CqE,MAAM,CAACrD,SADsC,EAE7CQ,IAAI,CAACR,SAFwC,CAA/C;;AAKA,gBAAIkC,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAA5B,EAAsC;AACpCZ,cAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAxB,CAAiCU,KAAjC,CAAuCH,MAAvC;AACD;;AACDnB,YAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAxB,GAAmCO,MAAnC;AACAT,YAAAA,aAAa,GAAG,IAAhB;AA1BmE;AA2BpE,SA3BM,MA2BA,IACLpC,IAAI,CAACe,aAAL,IACA,CAACf,IAAI,CAACkB,MADN,IAEAiB,iBAFA,IAGAP,YAAY,CAAChD,QAAb,CAAsBc,QAAtB,CAA+BM,IAAI,CAACR,SAAL,CAAe,CAAf,CAA/B,CAJK,EAKL;AACA;AACA;AACAoC,UAAAA,YAAY,CAAC9B,SAAb,CAAuB,uBAAvB,EAAgD,UAAAC,CAAC;AAAA,mBAAIA,CAAC,CAACkD,MAAF,EAAJ;AAAA,WAAjD;AACA/E,UAAAA,UAAU,CAACZ,IAAD,EAAOA,IAAI,CAACD,GAAL,CAAS8D,UAAhB,EAA4B7D,IAAI,CAACG,MAAL,CAAY0D,UAAxC,CAAV,CACGqB,OADH,GAEGnG,OAFH,CAEW,UAAAvB,CAAC;AAAA,mBACR8G,YAAY,CAACa,OAAb,CACEnC,MAAM,CAACoC,MAAP,CAAc5H,CAAd,EAAiB;AACf6H,cAAAA,IAAI,EAAE;AACJC,gBAAAA,OAAO,EAAEjB,QAAQ,CAACgB,IAAT,CAAcC;AADnB;AADS,aAAjB,CADF,CADQ;AAAA,WAFZ;AAWD,SApBM,MAoBA,IAAI5C,IAAI,CAACkB,MAAT,EAAiB;AAAA;AACtB;AACA;AACA;AACA;AACA,gBAAI2B,MAAM,GAAGjB,YAAY,CAACkB,KAAb,EAAb;AACAD,YAAAA,MAAM,CAACE,SAAP;AAEA7E,YAAAA,UAAU,CAACZ,IAAD,EAAOA,IAAI,CAACD,GAAL,CAAS8D,UAAhB,EAA4B7D,IAAI,CAACG,MAAL,CAAY0D,UAAxC,CAAV,CACGqB,OADH,GAEGnG,OAFH,CAEW,UAAAvB,CAAC;AAAA,qBACR+H,MAAM,CAACJ,OAAP,CACEnC,MAAM,CAACoC,MAAP,CAAc5H,CAAd,EAAiB;AACf6H,gBAAAA,IAAI,EAAE;AACJC,kBAAAA,OAAO,EAAEjB,QAAQ,CAACgB,IAAT,CAAcC;AADnB;AADS,eAAjB,CADF,CADQ;AAAA,aAFZ;;AAYA,gBAAI5C,IAAI,CAACe,aAAL,IAAsBsB,gBAA1B,EAA4C;AAC1CQ,cAAAA,MAAM,CAACrD,SAAP,GAAmBhB,4BAA4B,CAC7CqE,MAAM,CAACrD,SADsC,EAE7CQ,IAAI,CAACR,SAFwC,CAA/C;AAID;;AAEDqD,YAAAA,MAAM,CAACF,IAAP,GAAc3C,IAAI,CAACrF,IAAL,CAAUgI,IAAxB;;AAEA,gBAAI/C,GAAG,CAACrD,KAAJ,CAAUyD,IAAI,CAACrF,IAAL,CAAUQ,MAApB,IAA8B6G,iBAAlC,EAAqD;AACnD;AACA;AACAhC,cAAAA,IAAI,CAACrF,IAAL,CAAUQ,MAAV,CAAiB+H,MAAjB,CAAwBL,MAAxB;AACD,aAJD,MAIO;AACL;AACAnB,cAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBlC,IAAI,CAACkB,MAA7B,EAAqClG,IAArC,CAA0C6H,MAA1C;AACD,aApCqB,CAsCtB;AACA;;;AACA,gBAAI,CAACT,aAAL,EAAoB;AAClBV,cAAAA,aAAa,CAACQ,QAAD,CAAb,CAAwBI,QAAxB,GAAmCP,aAAa,IAAIH,YAApD;AACD;AA1CqB;AA2CvB;AACF;AA/KoC;AAAA;AAAA;AAAA;AAAA;;AAiLrC,WAAON,SAAP;AACD,GAlLD,EAZoC,CAgMpC;;AACAhB,EAAAA,MAAM,CAACC,IAAP,CAAYmB,aAAZ,EAA2BrF,OAA3B,CAAmC,UAAAiB,IAAI,EAAI;AACzC,QAAI2E,IAAI,GAAGP,aAAa,CAACpE,IAAD,CAAxB;AACA,QAAIgF,QAAQ,GAAGL,IAAI,CAACK,QAApB;AACAhC,IAAAA,MAAM,CAACC,IAAP,CAAY0B,IAAZ,EACGO,OADH,GAEGtG,MAFH,CAEU,UAAAiH,CAAC;AAAA,aAAIA,CAAC,KAAK,UAAV;AAAA,KAFX,EAGG9G,OAHH,CAGW,UAAA6E,MAAM,EAAI;AACjB,UAAIe,IAAI,CAACf,MAAD,CAAJ,CAAatH,MAAb,GAAsB,CAAtB,IAA2B0I,QAA/B,EAAyC;AACvCA,QAAAA,QAAQ,CAACU,KAAT,CAAe;AAAEzE,UAAAA,IAAI,EAAE,OAAR;AAAiB2C,UAAAA,MAAM,EAANA;AAAjB,SAAf;AACAoB,QAAAA,QAAQ,CAACc,IAAT,GAAgBF,MAAhB,CAAuBjB,IAAI,CAACf,MAAD,CAA3B;AACD;AACF,KARH;AASD,GAZD;AAcA,SAAOI,SAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxH,OAAO,CAACuJ,eAAR,GAA0BA,eAA1B;;AAEA,SAASA,eAAT,CAAyBlG,KAAzB,EAAgCzC,IAAhC,EAAsCmB,MAAtC,EAA8C;AAC5C,MAAIyH,MAAM,GAAGhD,MAAM,CAACC,IAAP,CAAYpD,KAAZ,CAAb;AAEAzC,EAAAA,IAAI,CAAC6I,IAAL,GAAYzD,SAAZ,CAAsB,WAAtB,EAAmC,UAAA6B,QAAQ,EAAI;AAC7C2B,IAAAA,MAAM,GAAGA,MAAM,CAACpH,MAAP,CAAc,UAAAsH,CAAC;AAAA,aAAIA,CAAC,KAAK7B,QAAQ,CAAChI,KAAnB;AAAA,KAAf,CAAT;AACD,GAFD;;AAIA,MAAI2J,MAAM,CAAC1J,MAAP,GAAgB,CAApB,EAAuB;AACrBc,IAAAA,IAAI,CAAC+I,IAAL,CAAU5H,MAAV,EAAkB,8BAA8ByH,MAAM,CAAC9G,IAAP,CAAY,IAAZ,CAAhD;AACD;;AAED,SAAO8E,SAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxH,OAAO,CAAC4J,4BAAR,GAAuCA,4BAAvC;;AAEA,SAASA,4BAAT,CAAsChJ,IAAtC,EAA4CmB,MAA5C,EAAoD;AAClD,MAAImE,IAAI,GAAGtF,IAAI,CAACS,MAAhB;AACA,MAAIoI,IAAI,GAAG7I,IAAI,CAAC6I,IAAL,EAAX;AACA,MAAIvC,eAAe,GAAG,KAAtB,CAHkD,CAKlD;;AACA,MAAI2C,iBAAiB,GAAGrK,IAAI,CACzBwF,KADqB,CACfkB,IAAI,CAACpB,QADU,EAErB1C,MAFqB,CAEd,UAAA0H,GAAG;AAAA,WAAIA,GAAG,KAAK,GAAZ;AAAA,GAFW,EAGrB3E,KAHqB,CAGf,CAHe,EAGZ,CAAC,CAHW,CAAxB,CANkD,CAWlD;AACA;;AACA,MAAI0E,iBAAiB,CAAC/J,MAAlB,GAA2B,CAA/B,EAAkC;AAChC,QAAIiK,iBAAiB,GAAG,KAAxB;AACA,QAAIC,iBAAiB,GAAG,IAAxB;AAEAP,IAAAA,IAAI,CAACzD,SAAL,CAAe,yBAAf,EAA0C,UAAAC,CAAC,EAAI;AAC7C,UAAI5E,MAAM,GAAG4E,CAAC,CAAC5E,MAAf;AACA,UAAIuD,iBAAiB,GAAGvD,MAAM,CAACqE,SAA/B;;AAEA,4BAAgBzB,aAAa,CAAC;AAAErD,QAAAA,IAAI,EAAEqF,CAAR;AAAWpE,QAAAA,GAAG,EAAEuE,UAAU,CAACH,CAAD;AAA1B,OAAD,CAA7B;AAAA,UAAM5C,KAAN,mBAAMA,KAAN;;AACA,UAAI4G,OAAO,GAAG5G,KAAK,CAACzC,IAAI,CAACf,KAAN,CAAnB,CAL6C,CAO7C;;AAP6C,kDAQrB+E,iBARqB;AAAA;;AAAA;AAQ7C,+DAA2C;AAAA,cAAlCU,WAAkC;;AACzC,cAAIyE,iBAAJ,EAAuB;AACrB;AACD;;AACD,cAAIG,cAAc,GAAG1K,IAAI,CAACwF,KAAL,CAAWM,WAAX,EAAwBlD,MAAxB,CAA+B,UAAA0H,GAAG;AAAA,mBAAIA,GAAG,KAAK,GAAZ;AAAA,WAAlC,CAArB;AAEAC,UAAAA,iBAAiB,GAAGG,cAAc,CAACC,KAAf,CAClB,UAAC3H,IAAD,EAAOmE,GAAP;AAAA,mBAAenE,IAAI,KAAKqH,iBAAiB,CAAClD,GAAD,CAAzC;AAAA,WADkB,CAApB;AAGD;AAjB4C;AAAA;AAAA;AAAA;AAAA;;AAmB7C,UAAIoD,iBAAiB,IAAI,CAACE,OAA1B,EAAmC;AACjC,eAAO,IAAP;AACD;;AAED,UAAI,CAACD,iBAAL,EAAwB;AACtBA,QAAAA,iBAAiB,GAAG3I,MAAM,CAACyD,QAA3B;AACD,OAzB4C,CA2B7C;;;AACA,UAAIkF,iBAAiB,IAAIA,iBAAiB,KAAK3I,MAAM,CAACyD,QAAtD,EAAgE;AAC9DoC,QAAAA,eAAe,GAAG,IAAlB;AACD;;AAED,aAAOM,SAAP;AACD,KAjCD,EAJgC,CAuChC;;AACA,QAAI,CAACuC,iBAAD,IAAsB7C,eAA1B,EAA2C;AACzCtG,MAAAA,IAAI,CAAC+I,IAAL,CACE5H,MADF,EAEE,6FACyCnB,IAAI,CAACf,KAD9C,kDAEkCgK,iBAAiB,CAACnH,IAAlB,CAAuB,GAAvB,CAFlC,CAFF;AAMD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1C,OAAO,CAACoK,yBAAR,GAAoCA,yBAApC;;AAEA,SAASA,yBAAT,CAAmCxJ,IAAnC,EAAyCmB,MAAzC,EAAiD;AAC/C,MAAImE,IAAI,GAAGtF,IAAI,CAACS,MAAhB;AACA,MAAIgJ,KAAK,GAAG,EAAZ;AACAnE,EAAAA,IAAI,CAACF,SAAL,CAAe,oBAAf,EAAqC,UAAAC,CAAC,EAAI;AACxC,QACE,CAACA,CAAC,CAAC7E,IAAF,CAAOkJ,QAAP,CAAgB,MAAhB,CAAD,IACA,CAACrE,CAAC,CAACpG,KAAF,CAAQ0K,UAAR,CAAmB,MAAnB,CADD,IAEA,CAACtE,CAAC,CAAC7E,IAAF,CAAOkJ,QAAP,CAAgB,MAAhB,CAHH,EAIE;AACAD,MAAAA,KAAK,CAACnJ,IAAN,CAAW+E,CAAX;AACD;AACF,GARD;;AASA,MAAIoE,KAAK,CAACvK,MAAN,GAAe,CAAnB,EAAsB;AACpBuK,IAAAA,KAAK,CAAC9H,OAAN,CAAc,UAAA0D,CAAC,EAAI;AACjBA,MAAAA,CAAC,CAAC0D,IAAF,CACE5H,MADF,EAEE,gHACwCkE,CAAC,CAAC7E,IAD1C,eAFF;AAKD,KAND;AAOD;;AAED,SAAOoG,SAAP;AACD,C,CAED;;;AAEAxH,OAAO,CAACoG,UAAR,GAAqBA,UAArB;;AAEA,SAASA,UAAT,CAAoBxF,IAApB,EAA0B;AACxB,MAAIiB,GAAG,GAAG,EAAV,CADwB,CAGxB;;AACA,MAAI2I,OAAO,GAAG,+BAAd;AACA5J,EAAAA,IAAI,CAACS,MAAL,CAAY2E,SAAZ,CAAsBwE,OAAtB,EAA+B,iBAAqB;AAAA,QAAlBpJ,IAAkB,SAAlBA,IAAkB;AAAA,QAAZvB,KAAY,SAAZA,KAAY;;AAClD,QAAI,gBAAgB6D,IAAhB,CAAqBtC,IAArB,CAAJ,EAAgC;AAC9B,yCAAsB9B,MAAM,CAACO,KAAD,CAAN,CAAckB,KAApC;AAAA,UAAKwC,GAAL;AAAA,UAAYI,MAAZ;;AAEA9B,MAAAA,GAAG,CAAC0B,GAAJ,GAAUA,GAAG,IAAIjE,MAAM,CAAC2C,SAAP,CAAiBsB,GAAjB,CAAjB;AACA1B,MAAAA,GAAG,CAAC8B,MAAJ,GAAaA,MAAM,GAAGrE,MAAM,CAAC2C,SAAP,CAAiB0B,MAAjB,CAAH,GAA8B9B,GAAG,CAAC0B,GAArD;AACD;;AACD,QAAI,oBAAoBG,IAApB,CAAyBtC,IAAzB,CAAJ,EAAoCS,GAAG,CAAC0B,GAAJ,GAAU1D,KAAV;AACpC,QAAI,uBAAuB6D,IAAvB,CAA4BtC,IAA5B,CAAJ,EAAuCS,GAAG,CAAC8B,MAAJ,GAAa9D,KAAb;AACxC,GATD;AAWA,SAAOgC,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAS4I,gBAAT,CAA0BrD,MAA1B,EAAkC;AAChC,MAAI,CAACA,MAAL,EAAa;AACX,WAAO,EAAP;AACD;;AACD,MAAIrB,MAAM,GAAGzG,MAAM,CAAC8H,MAAD,CAAnB;AACA,MAAIhG,IAAJ;AACA,MAAIvB,KAAJ;AAEAkG,EAAAA,MAAM,CAAC2E,IAAP,CAAY,UAAA7J,IAAI,EAAI;AAClB,QAAIA,IAAI,CAACI,IAAL,KAAc,MAAd,IAAwB,WAAWyC,IAAX,CAAgB7C,IAAI,CAAChB,KAArB,CAA5B,EAAyD;AACvDuB,MAAAA,IAAI,GAAGP,IAAI,CAAChB,KAAZ;AACD,KAFD,MAEO,IAAIgB,IAAI,CAAChB,KAAL,CAAW+F,QAAX,CAAoB,IAApB,CAAJ,EAA+B;AACpC/F,MAAAA,KAAK,GAAGE,QAAQ,CAACc,IAAI,CAAChB,KAAL,CAAW8B,OAAX,CAAmB,KAAnB,EAA0B,EAA1B,CAAD,CAAhB;AACD;AACF,GAND;AAQA,SAAO,CAACP,IAAD,EAAOvB,KAAP,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS8K,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AACpC,MAAI9I,MAAJ,CADoC,CAGpC;;AACA,MAAI+I,iBAAiB,GAAGnL,aAAa,CAACiL,IAAD,CAArC;AACA,MAAIG,iBAAiB,GAAGpL,aAAa,CAACkL,IAAD,CAArC;;AAEA,MAAIC,iBAAiB,CAAC,CAAD,CAAjB,CAAqBhL,MAArB,GAA8BiL,iBAAiB,CAAC,CAAD,CAAjB,CAAqBjL,MAAvD,EAA+D;AAC7D;AACA;AACA,WAAO,KAAP;AACD,GAJD,MAIO,IAAIgL,iBAAiB,CAAC,CAAD,CAAjB,CAAqBhL,MAArB,GAA8BiL,iBAAiB,CAAC,CAAD,CAAjB,CAAqBjL,MAAvD,EAA+D;AACpE;AACA;AAEA,QAAI6G,GAAG,GAAGmE,iBAAiB,CAAC,CAAD,CAAjB,CAAqBhJ,MAArB,CAA4B,UAACkJ,GAAD,SAAcvI,KAAd,EAAwB;AAAA;AAAA,UAAjBD,IAAiB;;AAC5D,UAAIyI,iBAAiB,GAAGF,iBAAiB,CAAC,CAAD,CAAjB,CAAqB,CAArB,EAAwB,CAAxB,CAAxB;;AACA,UAAIvI,IAAI,KAAKyI,iBAAb,EAAgC;AAC9B,eAAOxI,KAAP;AACD;;AACD,aAAO,KAAP;AACD,KANS,EAMP,KANO,CAAV;;AAQA,QAAIkE,GAAJ,EAAS;AACP5E,MAAAA,MAAM,GAAGgJ,iBAAiB,CAAC,CAAD,CAAjB,CAAqBZ,KAArB,CAA2B,UAACe,GAAD,EAAMzI,KAAN,EAAgB;AAClD,eAAOyI,GAAG,CAACf,KAAJ,CACL,UAACgB,IAAD,EAAOC,UAAP;AAAA,iBACE;AACA;AACAN,YAAAA,iBAAiB,CAAC,CAAD,CAAjB,CAAqB3F,KAArB,CAA2BwB,GAA3B,EAAgClE,KAAhC,EAAuC2I,UAAvC,MAAuDD;AAHzD;AAAA,SADK,CAAP;AAMD,OAPQ,CAAT;AAQD;AACF,GAtBM,MAsBA;AACL;AACA;AACApJ,IAAAA,MAAM,GAAGgJ,iBAAiB,CAACzJ,IAAlB,CAAuB,UAAA+J,UAAU,EAAI;AAC5C,aAAOA,UAAU,CAAClB,KAAX,CAAiB,UAACmB,UAAD,EAAa7I,KAAb,EAAuB;AAC7C,eAAO6I,UAAU,CAACnB,KAAX,CACL,UAACgB,IAAD,EAAOC,UAAP;AAAA,iBAAsBN,iBAAiB,CAAC,CAAD,CAAjB,CAAqBrI,KAArB,EAA4B2I,UAA5B,MAA4CD,IAAlE;AAAA,SADK,CAAP;AAGD,OAJM,CAAP;AAKD,KANQ,CAAT;AAOD;;AAED,SAAOpJ,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA/B,OAAO,CAACsG,cAAR,GAAyBA,cAAzB;;AAEA,SAASA,cAAT,CAAwB1F,IAAxB,EAA8BiB,GAA9B,EAAmC;AACjC,MAAIqE,IAAI,GAAGtF,IAAI,CAACS,MAAhB;AACA,MAAIkK,SAAS,GAAG/G,cAAc,CAAC0B,IAAD,CAA9B;AACA,MAAIuD,IAAI,GAAGvD,IAAI,CAACuD,IAAL,EAAX,CAHiC,CAKjC;;AACA,MAAI+B,gBAAgB,GAAG7L,aAAa,CAACuG,IAAI,CAACpB,QAAN,CAApC,CANiC,CAQjC;;AACA,MAAI0B,MAAM,CAACC,IAAP,CAAY5E,GAAZ,EAAiB/B,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,WAAO,KAAP;AACD,GAXgC,CAajC;;;AACA,0BAAa2K,gBAAgB,CAACc,SAAS,CAACnE,MAAX,CAA7B;AAAA;AAAA,MAAKhG,IAAL;;AAEA,MAAIqK,WAAW,GAAGD,gBAAgB,CAAC,CAAD,CAAlC,CAhBiC,CAkBjC;AACA;;AACA,MAAIE,OAAO,GAAGhM,YAAY,CAAC+L,WAAW,CAACA,WAAW,CAAC3L,MAAZ,GAAqB,CAAtB,CAAX,CAAoC,CAApC,CAAD,CAA1B;AAEA,MAAI6L,MAAM,GAAG,IAAIC,MAAJ,YAAeF,OAAf,iBAA6BA,OAA7B,WAAb,CAtBiC,CAwBjC;;AACA,MAAIG,cAAJ;AACApC,EAAAA,IAAI,CAACqC,SAAL,CAAeH,MAAf,EAAuB,UAAA3E,CAAC,EAAI;AAC1B,QAAI+E,OAAJ,CAD0B,CAG1B;;AACA,QAAI7F,IAAI,CAAC1E,QAAL,OAAoBwF,CAAC,CAACxF,QAAF,EAAxB,EAAsC;AACpC,aAAO,KAAP;AACD,KANyB,CAQ1B;;;AACAwF,IAAAA,CAAC,CAAChB,SAAF,CAAY,UAAZ,EAAwB,UAAAC,CAAC;AAAA,aAAK8F,OAAO,GAAG3F,UAAU,CAACH,CAAD,CAAzB;AAAA,KAAzB,EAT0B,CAW1B;;AACA,QAAI,CAAC8F,OAAD,IAAYvF,MAAM,CAACC,IAAP,CAAYsF,OAAZ,EAAqBjM,MAArB,KAAgC,CAAhD,EAAmD;AACjD,aAAO,IAAP;AACD,KAdyB,CAgB1B;;;AACA,QAAI,CAAC6K,gBAAgB,CAACzE,IAAI,CAACpB,QAAN,EAAgBkC,CAAC,CAAClC,QAAlB,CAArB,EAAkD;AAChD,aAAO,IAAP;AACD;;AAED,QAAIqB,KAAK,GAAG3B,cAAc,CAACwC,CAAD,CAA1B;;AACA,QAAIb,KAAJ,EAAW;AACT;AACA;AACA,UAAI6F,aAAa,GAAGvB,gBAAgB,CAACtE,KAAK,CAACiB,MAAP,CAAhB,CAA+B,CAA/B,CAApB;;AACA,UAAI4E,aAAa,KAAK5K,IAAtB,EAA4B;AAC1ByK,QAAAA,cAAc,GAAGE,OAAjB;AACA,eAAO,IAAP;AACD;AACF,KARD,MAQO;AACLF,MAAAA,cAAc,GAAGE,OAAjB;AACA,aAAO,IAAP;AACD;;AAED,WAAOvE,SAAP;AACD,GApCD,EA1BiC,CAgEjC;;AACA,MAAIqE,cAAc,IAAIrF,MAAM,CAACC,IAAP,CAAYoF,cAAZ,EAA4B/L,MAA5B,GAAqC,CAA3D,EAA8D;AAC5D,WAAO+L,cAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED7L,OAAO,CAACiM,WAAR,GAAsBA,WAAtB;;AAEA,SAASA,WAAT,SAAwD;AAAA,MAAjCpK,GAAiC,UAAjCA,GAAiC;AAAA,MAA5BqK,UAA4B,UAA5BA,UAA4B;AAAA,MAAhBtL,IAAgB,UAAhBA,IAAgB;AAAA,MAAVmB,MAAU,UAAVA,MAAU;AACtD,MAAIoK,WAAW,GAAGtK,GAAG,CAAC0B,GAAJ,IAAW1B,GAAG,CAAC8B,MAAjC;;AACA,MAAI,CAACuI,UAAD,KAAgBC,WAAW,IAAKtK,GAAG,CAAC8B,MAAJ,IAAc,CAAC9B,GAAG,CAAC0B,GAAnD,CAAJ,EAA8D;AAC5D,WAAO1B,GAAG,CAAC8B,MAAX;AACA/C,IAAAA,IAAI,CAAC+I,IAAL,CACE5H,MADF,EAEE,0DAFF;AAID;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqK,kBAAT,CAA4BtC,GAA5B,EAAiC;AAC/B,MAAIuC,UAAU,GAAG/M,MAAM,CAACwK,GAAD,CAAN,CAAY/I,KAAZ,CAAkBe,MAAlB,CAAyB,UAACC,MAAD,EAASlB,IAAT,EAAkB;AAC1D,QAAIA,IAAI,CAACI,IAAL,KAAc,UAAd,IAA4BJ,IAAI,CAAChB,KAAL,KAAe,QAA/C,EAAyD;AACvD,UAAImC,GAAG,GAAG,OAAV;;AAEA,+BAAqBnB,IAAI,CAACE,KAAL,CAAWe,MAAX,CACnB,UAAC4E,GAAD,EAAM4F,CAAN,EAAY;AACV,YAAIA,CAAC,CAACrL,IAAF,KAAW,MAAX,IAAqBe,GAAG,KAAK,OAAjC,EAA0C;AACxC0E,UAAAA,GAAG,CAAC,CAAD,CAAH,GAAS9C,IAAI,CAAC2I,GAAL,CAASxM,QAAQ,CAACuM,CAAC,CAACzM,KAAH,CAAjB,CAAT;AACA,iBAAO6G,GAAP;AACD;;AACD,YAAI4F,CAAC,CAACrL,IAAF,KAAW,KAAX,IAAoBqL,CAAC,CAACzM,KAAF,KAAY,GAApC,EAAyC;AACvCmC,UAAAA,GAAG,GAAG,OAAN;AACA,iBAAO0E,GAAP;AACD;;AACD,YAAI1E,GAAG,KAAK,OAAZ,EAAqB;AACnB0E,UAAAA,GAAG,CAAC,CAAD,CAAH,IAAUpH,MAAM,CAAC2C,SAAP,CAAiBqK,CAAjB,CAAV;AACD;;AACD,eAAO5F,GAAP;AACD,OAdkB,EAenB,CAAC,CAAD,EAAI,EAAJ,CAfmB,CAArB;AAAA;AAAA,UAAKvE,KAAL;AAAA,UAAYtC,KAAZ;;AAkBA,UAAIsC,KAAJ,EAAW;AACT,aAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,KAApB,EAA2BnB,CAAC,EAA5B,EAAgC;AAC9Be,UAAAA,MAAM,CAACb,IAAP,CAAYrB,KAAZ;AACD;AACF;;AAED,aAAOkC,MAAP;AACD;;AACD,QAAIlB,IAAI,CAACI,IAAL,KAAc,OAAlB,EAA2B;AACzB,aAAOc,MAAP;AACD;;AACD,WAAOA,MAAM,CAACa,MAAP,CAActD,MAAM,CAAC2C,SAAP,CAAiBpB,IAAjB,CAAd,CAAP;AACD,GAlCgB,EAkCd,EAlCc,CAAjB;AAoCA,SAAOwL,UAAP;AACD;;AAEDrM,OAAO,CAACwM,kBAAR,GAA6BA,kBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,kBAAT,CAA4B5L,IAA5B,EAAkCmB,MAAlC,EAA0CF,GAA1C,EAAsE;AAAA,MAAvB4K,aAAuB,uEAAP,KAAO;AACpE,MAAMpL,MAAN,GAAiBT,IAAjB,CAAMS,MAAN;AAEA,MAAIqL,OAAO,GAAGrL,MAAM,CAACN,KAAP,CAAa4L,IAAb,CAAkB,UAAA3L,CAAC;AAAA,WAAIA,CAAC,CAACI,IAAF,KAAW,oBAAf;AAAA,GAAnB,CAAd;AACA,MAAIgC,IAAI,GAAGgJ,kBAAkB,CAACM,OAAO,CAAC7M,KAAT,CAA7B;AACA,MAAIsE,OAAO,GAAGiI,kBAAkB,CAACxL,IAAI,CAACf,KAAN,CAAhC,CALoE,CAOpE;AACA;;AACA,MAAI+M,UAAU,GAAGxJ,IAAI,CAACyB,GAAL,CAAS,UAACgI,CAAD,EAAIvJ,QAAJ,EAAiB;AACzC,WAAOwJ,KAAK,CAACC,IAAN,CACL;AAAEjN,MAAAA,MAAM,EAAEqE,OAAO,CAACrE;AAAlB,KADK,EAEL,UAACkN,CAAD,EAAIC,CAAJ;AAAA,aAAUA,CAAC,GAAG3J,QAAQ,GAAGa,OAAO,CAACrE,MAAvB,GAAgC,CAA1C;AAAA,KAFK,EAGL4C,IAHK,CAGA,GAHA,CAAP;AAID,GALgB,CAAjB;AAOA,MAAIW,KAAK,GAAGF,cAAc,CAAC;AAAEC,IAAAA,IAAI,EAAEwJ,UAAR;AAAoB/K,IAAAA,GAAG,EAAHA;AAApB,GAAD,CAA1B;AACA,MAAI4E,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYpD,KAAZ,CAAX;AACA,MAAI6J,KAAK,GAAGzG,IAAI,CAAC5B,GAAL,CAAS,UAAA7D,CAAC;AAAA,WAAIqC,KAAK,CAACrC,CAAD,CAAT;AAAA,GAAV,CAAZ,CAlBoE,CAoBpE;;AACA,MAAIyL,aAAa,CAAC7G,QAAd,CAAuB,QAAvB,CAAJ,EAAsC;AACpCsH,IAAAA,KAAK,GAAGA,KAAK,CAACC,IAAN,CAAW,UAACC,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,CAACzJ,MAAF,CAASpD,KAAT,GAAiB8M,CAAC,CAAC1J,MAAF,CAASpD,KAApC;AAAA,KAAX,CAAR;AACD,GAvBmE,CAyBpE;;;AACA2M,EAAAA,KAAK,CAACxE,OAAN,GAAgBnG,OAAhB,CAAwB,UAACC,IAAD,EAAOC,KAAP,EAAiB;AACvC,QAAMkB,MAAN,GAAsBnB,IAAtB,CAAMmB,MAAN;AAAA,QAAcJ,GAAd,GAAsBf,IAAtB,CAAce,GAAd;AACA,QAAI+J,YAAY,GAAGjM,MAAM,CAACqE,SAAP,CAChBb,GADgB,CACZ,UAAAc,GAAG;AAAA,aAAIA,GAAG,4BAAqBc,IAAI,CAAC3G,MAAL,GAAc2C,KAAnC,MAAP;AAAA,KADS,EAEhBC,IAFgB,CAEX,IAFW,CAAnB,CAFuC,CAMvC;;AACA,QAAI7B,IAAI,GAAGQ,MAAM,CAAC2H,KAAP,GAAeC,SAAf,EAAX,CAPuC,CASvC;;AACApI,IAAAA,IAAI,CAACiE,QAAL,GAAgBwI,YAAhB,CAVuC,CAYvC;;AACAzM,IAAAA,IAAI,CAACuI,MAAL,CAAY;AAAEhI,MAAAA,IAAI,EAAE,cAAR;AAAwBvB,MAAAA,KAAK,EAAE0D,GAAG,CAAChD;AAAnC,KAAZ;AACAM,IAAAA,IAAI,CAACuI,MAAL,CAAY;AAAEhI,MAAAA,IAAI,EAAE,iBAAR;AAA2BvB,MAAAA,KAAK,EAAE8D,MAAM,CAACpD;AAAzC,KAAZ,EAduC,CAgBvC;;AACAc,IAAAA,MAAM,CAAC6H,KAAP,CAAarI,IAAb;AACD,GAlBD;AAoBA,SAAO2G,SAAP;AACD","sourcesContent":["let parser = require('postcss-value-parser')\nlet list = require('postcss').list\n\nlet uniq = require('../utils').uniq\nlet escapeRegexp = require('../utils').escapeRegexp\nlet splitSelector = require('../utils').splitSelector\n\nfunction convert(value) {\n  if (\n    value &&\n    value.length === 2 &&\n    value[0] === 'span' &&\n    parseInt(value[1], 10) > 0\n  ) {\n    return [false, parseInt(value[1], 10)]\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false]\n  }\n\n  return [false, false]\n}\n\nexports.translate = translate\n\nfunction translate(values, startIndex, endIndex) {\n  let startValue = values[startIndex]\n  let endValue = values[endIndex]\n\n  if (!startValue) {\n    return [false, false]\n  }\n\n  let [start, spanStart] = convert(startValue)\n  let [end, spanEnd] = convert(endValue)\n\n  if (start && !endValue) {\n    return [start, false]\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart]\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd]\n  }\n\n  if (start && end) {\n    return [start, end - start]\n  }\n\n  return [false, false]\n}\n\nexports.parse = parse\n\nfunction parse(decl) {\n  let node = parser(decl.value)\n\n  let values = []\n  let current = 0\n  values[current] = []\n\n  for (let i of node.nodes) {\n    if (i.type === 'div') {\n      current += 1\n      values[current] = []\n    } else if (i.type === 'word') {\n      values[current].push(i.value)\n    }\n  }\n\n  return values\n}\n\nexports.insertDecl = insertDecl\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {\n    decl.cloneBefore({\n      prop: `-ms-${prop}`,\n      value: value.toString()\n    })\n  }\n}\n\n// Track transforms\n\nexports.prefixTrackProp = prefixTrackProp\n\nfunction prefixTrackProp({ prop, prefix }) {\n  return prefix + prop.replace('template-', '')\n}\n\nfunction transformRepeat({ nodes }, { gap }) {\n  let { count, size } = nodes.reduce(\n    (result, node) => {\n      if (node.type === 'div' && node.value === ',') {\n        result.key = 'size'\n      } else {\n        result[result.key].push(parser.stringify(node))\n      }\n      return result\n    },\n    {\n      key: 'count',\n      size: [],\n      count: []\n    }\n  )\n\n  // insert gap values\n  if (gap) {\n    size = size.filter(i => i.trim())\n    let val = []\n    for (let i = 1; i <= count; i++) {\n      size.forEach((item, index) => {\n        if (index > 0 || i > 1) {\n          val.push(gap)\n        }\n        val.push(item)\n      })\n    }\n\n    return val.join(' ')\n  }\n\n  return `(${size.join('')})[${count.join('')}]`\n}\n\nexports.prefixTrackValue = prefixTrackValue\n\nfunction prefixTrackValue({ value, gap }) {\n  let result = parser(value).nodes.reduce((nodes, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, { gap })\n      })\n    }\n    if (gap && node.type === 'space') {\n      return nodes.concat(\n        {\n          type: 'space',\n          value: ' '\n        },\n        {\n          type: 'word',\n          value: gap\n        },\n        node\n      )\n    }\n    return nodes.concat(node)\n  }, [])\n\n  return parser.stringify(result)\n}\n\n// Parse grid-template-areas\n\nlet DOTS = /^\\.+$/\n\nfunction track(start, end) {\n  return { start, end, span: end - start }\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g)\n}\n\nexports.parseGridAreas = parseGridAreas\n\nfunction parseGridAreas({ rows, gap }) {\n  return rows.reduce((areas, line, rowIndex) => {\n    if (gap.row) rowIndex *= 2\n\n    if (line.trim() === '') return areas\n\n    getColumns(line).forEach((area, columnIndex) => {\n      if (DOTS.test(area)) return\n\n      if (gap.column) columnIndex *= 2\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        }\n      } else {\n        let { column, row } = areas[area]\n\n        column.start = Math.min(column.start, columnIndex + 1)\n        column.end = Math.max(column.end, columnIndex + 2)\n        column.span = column.end - column.start\n\n        row.start = Math.min(row.start, rowIndex + 1)\n        row.end = Math.max(row.end, rowIndex + 2)\n        row.span = row.end - row.start\n      }\n    })\n\n    return areas\n  }, {})\n}\n\n// Parse grid-template\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+]$/.test(node.value)\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto')\n  }\n  return result\n}\n\nexports.parseTemplate = parseTemplate\n\nfunction parseTemplate({ decl, gap }) {\n  let gridTemplate = parser(decl.value).nodes.reduce(\n    (result, node) => {\n      let { type, value } = node\n\n      if (testTrack(node) || type === 'space') return result\n\n      // area\n      if (type === 'string') {\n        result = verifyRowSize(result)\n        result.areas.push(value)\n      }\n\n      // values and function\n      if (type === 'word' || type === 'function') {\n        result[result.key].push(parser.stringify(node))\n      }\n\n      // divider(/)\n      if (type === 'div' && value === '/') {\n        result.key = 'columns'\n        result = verifyRowSize(result)\n      }\n\n      return result\n    },\n    {\n      key: 'rows',\n      columns: [],\n      rows: [],\n      areas: []\n    }\n  )\n\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  }\n}\n\n// Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\nfunction getMSDecls(area, addRowSpan = false, addColumnSpan = false) {\n  let result = [\n    {\n      prop: '-ms-grid-row',\n      value: String(area.row.start)\n    }\n  ]\n  if (area.row.span > 1 || addRowSpan) {\n    result.push({\n      prop: '-ms-grid-row-span',\n      value: String(area.row.span)\n    })\n  }\n  result.push({\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  })\n  if (area.column.span > 1 || addColumnSpan) {\n    result.push({\n      prop: '-ms-grid-column-span',\n      value: String(area.column.span)\n    })\n  }\n  return result\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent\n  }\n  if (!parent.parent) {\n    return false\n  }\n  return getParentMedia(parent.parent)\n}\n\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(selector => {\n    let selectorBySpace = list.space(selector)\n    let selectorByComma = list.comma(selector)\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('')\n    }\n    return selector\n  })\n\n  return ruleSelectors.map(ruleSelector => {\n    let newSelector = templateSelectors.map((tplSelector, index) => {\n      let space = index === 0 ? '' : ' '\n      return `${space}${tplSelector} > ${ruleSelector}`\n    })\n\n    return newSelector\n  })\n}\n\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(sel => {\n    return ruleB.selectors.includes(sel)\n  })\n}\n\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\nfunction parseGridTemplatesData(css) {\n  let parsed = []\n\n  // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n  css.walkDecls(/grid-template(-areas)?$/, d => {\n    let rule = d.parent\n    let media = getParentMedia(rule)\n    let gap = getGridGap(d)\n    let inheritedGap = inheritGridGap(d, gap)\n    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })\n    let areaNames = Object.keys(areas)\n\n    // skip node if it doesn't have areas\n    if (areaNames.length === 0) {\n      return true\n    }\n\n    // check parsed array for item that include the same area names\n    // return index of that item\n    let index = parsed.reduce((acc, { allAreas }, idx) => {\n      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))\n      return hasAreas ? idx : acc\n    }, null)\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      let { allAreas, rules } = parsed[index]\n\n      // check if rule has no duplicate area names\n      let hasNoDuplicates = rules.some(r => {\n        return r.hasDuplicates === false && selectorsEqual(r, rule)\n      })\n\n      let duplicatesFound = false\n\n      // check need to gather all duplicate area names\n      let duplicateAreaNames = rules.reduce((acc, r) => {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true\n          return r.duplicateAreaNames\n        }\n        if (!duplicatesFound) {\n          areaNames.forEach(name => {\n            if (r.areas[name]) {\n              acc.push(name)\n            }\n          })\n        }\n        return uniq(acc)\n      }, [])\n\n      // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n      rules.forEach(r => {\n        areaNames.forEach(name => {\n          let area = r.areas[name]\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true\n          }\n        })\n      })\n\n      parsed[index].allAreas = uniq([...allAreas, ...areaNames])\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames,\n        areas\n      })\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [\n          {\n            hasDuplicates: false,\n            duplicateRules: [],\n            params: media.params,\n            selectors: rule.selectors,\n            node: rule,\n            duplicateAreaNames: [],\n            areas\n          }\n        ]\n      })\n    }\n\n    return undefined\n  })\n\n  return parsed\n}\n\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\nexports.insertAreas = insertAreas\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  let gridTemplatesData = parseGridTemplatesData(css)\n\n  // return undefined if no declarations found\n  if (gridTemplatesData.length === 0) {\n    return undefined\n  }\n\n  // we need to store the rules that we will insert later\n  let rulesToInsert = {}\n\n  css.walkDecls('grid-area', gridArea => {\n    let gridAreaRule = gridArea.parent\n    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'\n    let gridAreaMedia = getParentMedia(gridAreaRule)\n\n    if (isDisabled(gridArea)) {\n      return undefined\n    }\n\n    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)\n\n    let value = gridArea.value\n    // found the data that matches grid-area identifier\n    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]\n\n    if (!data) {\n      return true\n    }\n\n    let lastArea = data.allAreas[data.allAreas.length - 1]\n    let selectorBySpace = list.space(gridAreaRule.selector)\n    let selectorByComma = list.comma(gridAreaRule.selector)\n    let selectorIsComplex =\n      selectorBySpace.length > 1 &&\n      selectorBySpace.length > selectorByComma.length\n\n    // prevent doubling of prefixes\n    if (hasPrefixedRow) {\n      return false\n    }\n\n    // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {}\n    }\n\n    let lastRuleIsSet = false\n\n    // walk through every grid-template rule data\n    for (let rule of data.rules) {\n      let area = rule.areas[value]\n      let hasDuplicateName = rule.duplicateAreaNames.includes(value)\n\n      // if we can't find the area name, update lastRule and continue\n      if (!area) {\n        let lastRule = rulesToInsert[lastArea].lastRule\n        let lastRuleIndex\n        if (lastRule) {\n          lastRuleIndex = css.index(lastRule)\n        } else {\n          /* c8 ignore next 2 */\n          lastRuleIndex = -1\n        }\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n        continue\n      }\n\n      // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = []\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n\n        getMSDecls(area, false, false)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        rulesToInsert[lastArea].lastRule = gridAreaRule\n        lastRuleIsSet = true\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        // grid-template has duplicates and not inside media rule\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        cloned.selectors = changeDuplicateAreaSelectors(\n          cloned.selectors,\n          rule.selectors\n        )\n\n        if (rulesToInsert[lastArea].lastRule) {\n          rulesToInsert[lastArea].lastRule.after(cloned)\n        }\n        rulesToInsert[lastArea].lastRule = cloned\n        lastRuleIsSet = true\n      } else if (\n        rule.hasDuplicates &&\n        !rule.params &&\n        selectorIsComplex &&\n        gridAreaRule.selector.includes(rule.selectors[0])\n      ) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            gridAreaRule.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n      } else if (rule.params) {\n        // grid-template is inside media rule\n        // if we're inside media rule, we need to store prefixed rules\n        // inside rulesToInsert object to be able to preserve the order of media\n        // rules and merge them easily\n        let cloned = gridAreaRule.clone()\n        cloned.removeAll()\n\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)\n          .reverse()\n          .forEach(i =>\n            cloned.prepend(\n              Object.assign(i, {\n                raws: {\n                  between: gridArea.raws.between\n                }\n              })\n            )\n          )\n\n        if (rule.hasDuplicates && hasDuplicateName) {\n          cloned.selectors = changeDuplicateAreaSelectors(\n            cloned.selectors,\n            rule.selectors\n          )\n        }\n\n        cloned.raws = rule.node.raws\n\n        if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n          // append the prefixed rules right inside media rule\n          // with grid-template\n          rule.node.parent.append(cloned)\n        } else {\n          // store the rule to insert later\n          rulesToInsert[lastArea][rule.params].push(cloned)\n        }\n\n        // set new rule as last rule ONLY if we didn't set lastRule for\n        // this grid-area before\n        if (!lastRuleIsSet) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule\n        }\n      }\n    }\n\n    return undefined\n  })\n\n  // append stored rules inside the media rules\n  Object.keys(rulesToInsert).forEach(area => {\n    let data = rulesToInsert[area]\n    let lastRule = data.lastRule\n    Object.keys(data)\n      .reverse()\n      .filter(p => p !== 'lastRule')\n      .forEach(params => {\n        if (data[params].length > 0 && lastRule) {\n          lastRule.after({ name: 'media', params })\n          lastRule.next().append(data[params])\n        }\n      })\n  })\n\n  return undefined\n}\n\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnMissedAreas = warnMissedAreas\n\nfunction warnMissedAreas(areas, decl, result) {\n  let missed = Object.keys(areas)\n\n  decl.root().walkDecls('grid-area', gridArea => {\n    missed = missed.filter(e => e !== gridArea.value)\n  })\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))\n  }\n\n  return undefined\n}\n\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  let rule = decl.parent\n  let root = decl.root()\n  let duplicatesFound = false\n\n  // slice selector array. Remove the last part (for comparison)\n  let slicedSelectorArr = list\n    .space(rule.selector)\n    .filter(str => str !== '>')\n    .slice(0, -1)\n\n  // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n  if (slicedSelectorArr.length > 0) {\n    let gridTemplateFound = false\n    let foundAreaSelector = null\n\n    root.walkDecls(/grid-template(-areas)?$/, d => {\n      let parent = d.parent\n      let templateSelectors = parent.selectors\n\n      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })\n      let hasArea = areas[decl.value]\n\n      // find the the matching selectors\n      for (let tplSelector of templateSelectors) {\n        if (gridTemplateFound) {\n          break\n        }\n        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')\n\n        gridTemplateFound = tplSelectorArr.every(\n          (item, idx) => item === slicedSelectorArr[idx]\n        )\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector\n      }\n\n      // if we found the duplicate area with different selector\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true\n      }\n\n      return undefined\n    })\n\n    // warn user if we didn't find template\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(\n        result,\n        'Autoprefixer cannot find a grid-template ' +\n          `containing the duplicate grid-area \"${decl.value}\" ` +\n          `with full selector matching: ${slicedSelectorArr.join(' ')}`\n      )\n    }\n  }\n}\n\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\nexports.warnIfGridRowColumnExists = warnIfGridRowColumnExists\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  let rule = decl.parent\n  let decls = []\n  rule.walkDecls(/^grid-(row|column)/, d => {\n    if (\n      !d.prop.endsWith('-end') &&\n      !d.value.startsWith('span') &&\n      !d.prop.endsWith('-gap')\n    ) {\n      decls.push(d)\n    }\n  })\n  if (decls.length > 0) {\n    decls.forEach(d => {\n      d.warn(\n        result,\n        'You already have a grid-area declaration present in the rule. ' +\n          `You should use either grid-area or ${d.prop}, not both`\n      )\n    })\n  }\n\n  return undefined\n}\n\n// Gap utils\n\nexports.getGridGap = getGridGap\n\nfunction getGridGap(decl) {\n  let gap = {}\n\n  // try to find gap\n  let testGap = /^(grid-)?((row|column)-)?gap$/\n  decl.parent.walkDecls(testGap, ({ prop, value }) => {\n    if (/^(grid-)?gap$/.test(prop)) {\n      let [row, , column] = parser(value).nodes\n\n      gap.row = row && parser.stringify(row)\n      gap.column = column ? parser.stringify(column) : gap.row\n    }\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value\n  })\n\n  return gap\n}\n\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\nfunction parseMediaParams(params) {\n  if (!params) {\n    return []\n  }\n  let parsed = parser(params)\n  let prop\n  let value\n\n  parsed.walk(node => {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''))\n    }\n  })\n\n  return [prop, value]\n}\n\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\nfunction shouldInheritGap(selA, selB) {\n  let result\n\n  // get arrays of selector split in 3-deep array\n  let splitSelectorArrA = splitSelector(selA)\n  let splitSelectorArrB = splitSelector(selB)\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n\n    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {\n      let firstSelectorPart = splitSelectorArrB[0][0][0]\n      if (item === firstSelectorPart) {\n        return index\n      }\n      return false\n    }, false)\n\n    if (idx) {\n      result = splitSelectorArrB[0].every((arr, index) => {\n        return arr.every(\n          (part, innerIndex) =>\n            // because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n        )\n      })\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(byCommaArr => {\n      return byCommaArr.every((bySpaceArr, index) => {\n        return bySpaceArr.every(\n          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part\n        )\n      })\n    })\n  }\n\n  return result\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\nexports.inheritGridGap = inheritGridGap\n\nfunction inheritGridGap(decl, gap) {\n  let rule = decl.parent\n  let mediaRule = getParentMedia(rule)\n  let root = rule.root()\n\n  // get an array of selector split in 3-deep array\n  let splitSelectorArr = splitSelector(rule.selector)\n\n  // abort if the rule already has gaps\n  if (Object.keys(gap).length > 0) {\n    return false\n  }\n\n  // e.g ['min-width']\n  let [prop] = parseMediaParams(mediaRule.params)\n\n  let lastBySpace = splitSelectorArr[0]\n\n  // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])\n\n  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)\n\n  // find the closest rule with the same selector\n  let closestRuleGap\n  root.walkRules(regexp, r => {\n    let gridGap\n\n    // abort if are checking the same rule\n    if (rule.toString() === r.toString()) {\n      return false\n    }\n\n    // find grid-gap values\n    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))\n\n    // skip rule without gaps\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true\n    }\n\n    // skip rules that should not be inherited from\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true\n    }\n\n    let media = getParentMedia(r)\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      let propToCompare = parseMediaParams(media.params)[0]\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap\n        return true\n      }\n    } else {\n      closestRuleGap = gridGap\n      return true\n    }\n\n    return undefined\n  })\n\n  // if we find the closest gap object\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap\n  }\n  return false\n}\n\nexports.warnGridGap = warnGridGap\n\nfunction warnGridGap({ gap, hasColumns, decl, result }) {\n  let hasBothGaps = gap.row && gap.column\n  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {\n    delete gap.column\n    decl.warn(\n      result,\n      'Can not implement grid-gap without grid-template-columns'\n    )\n  }\n}\n\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\nfunction normalizeRowColumn(str) {\n  let normalized = parser(str).nodes.reduce((result, node) => {\n    if (node.type === 'function' && node.value === 'repeat') {\n      let key = 'count'\n\n      let [count, value] = node.nodes.reduce(\n        (acc, n) => {\n          if (n.type === 'word' && key === 'count') {\n            acc[0] = Math.abs(parseInt(n.value))\n            return acc\n          }\n          if (n.type === 'div' && n.value === ',') {\n            key = 'value'\n            return acc\n          }\n          if (key === 'value') {\n            acc[1] += parser.stringify(n)\n          }\n          return acc\n        },\n        [0, '']\n      )\n\n      if (count) {\n        for (let i = 0; i < count; i++) {\n          result.push(value)\n        }\n      }\n\n      return result\n    }\n    if (node.type === 'space') {\n      return result\n    }\n    return result.concat(parser.stringify(node))\n  }, [])\n\n  return normalized\n}\n\nexports.autoplaceGridItems = autoplaceGridItems\n\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\nfunction autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {\n  let { parent } = decl\n\n  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')\n  let rows = normalizeRowColumn(rowDecl.value)\n  let columns = normalizeRowColumn(decl.value)\n\n  // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n  let filledRows = rows.map((_, rowIndex) => {\n    return Array.from(\n      { length: columns.length },\n      (v, k) => k + rowIndex * columns.length + 1\n    ).join(' ')\n  })\n\n  let areas = parseGridAreas({ rows: filledRows, gap })\n  let keys = Object.keys(areas)\n  let items = keys.map(i => areas[i])\n\n  // Change the order of cells if grid-auto-flow value is 'column'\n  if (autoflowValue.includes('column')) {\n    items = items.sort((a, b) => a.column.start - b.column.start)\n  }\n\n  // Insert new rules\n  items.reverse().forEach((item, index) => {\n    let { column, row } = item\n    let nodeSelector = parent.selectors\n      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)\n      .join(', ')\n\n    // create new rule\n    let node = parent.clone().removeAll()\n\n    // change rule selector\n    node.selector = nodeSelector\n\n    // insert prefixed row/column values\n    node.append({ prop: '-ms-grid-row', value: row.start })\n    node.append({ prop: '-ms-grid-column', value: column.start })\n\n    // insert rule\n    parent.after(node)\n  })\n\n  return undefined\n}\n"]},"metadata":{},"sourceType":"script"}