{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\n\nvar _require = require('caniuse-lite'),\n    feature = _require.feature;\n\nvar _require2 = require('postcss'),\n    parse = _require2.parse;\n\nvar Browsers = require('./browsers');\n\nvar brackets = require('./brackets');\n\nvar Value = require('./value');\n\nvar utils = require('./utils');\n\nvar data = feature(featureQueries);\nvar supported = [];\n\nfor (var browser in data.stats) {\n  var versions = data.stats[browser];\n\n  for (var version in versions) {\n    var support = versions[version];\n\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\n\nvar Supports = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Supports(Prefixes, all) {\n    _classCallCheck(this, Supports);\n\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n\n\n  _createClass(Supports, [{\n    key: \"prefixer\",\n    value: function prefixer() {\n      if (this.prefixerCache) {\n        return this.prefixerCache;\n      }\n\n      var filtered = this.all.browsers.selected.filter(function (i) {\n        return supported.includes(i);\n      });\n      var browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n      this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n      return this.prefixerCache;\n    }\n    /**\n     * Parse string into declaration property and value\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(str) {\n      var parts = str.split(':');\n      var prop = parts[0];\n      var value = parts[1];\n      if (!value) value = '';\n      return [prop.trim(), value.trim()];\n    }\n    /**\n     * Create virtual rule to process it by prefixer\n     */\n\n  }, {\n    key: \"virtual\",\n    value: function virtual(str) {\n      var _this$parse = this.parse(str),\n          _this$parse2 = _slicedToArray(_this$parse, 2),\n          prop = _this$parse2[0],\n          value = _this$parse2[1];\n\n      var rule = parse('a{}').first;\n      rule.append({\n        prop: prop,\n        value: value,\n        raws: {\n          before: ''\n        }\n      });\n      return rule;\n    }\n    /**\n     * Return array of Declaration with all necessary prefixes\n     */\n\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(str) {\n      var rule = this.virtual(str);\n\n      if (this.disabled(rule.first)) {\n        return rule.nodes;\n      }\n\n      var result = {\n        warn: function warn() {\n          return null;\n        }\n      };\n      var prefixer = this.prefixer().add[rule.first.prop];\n      prefixer && prefixer.process && prefixer.process(rule.first, result);\n\n      var _iterator = _createForOfIteratorHelper(rule.nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var decl = _step.value;\n\n          var _iterator2 = _createForOfIteratorHelper(this.prefixer().values('add', rule.first.prop)),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var value = _step2.value;\n              value.process(decl);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          Value.save(this.all, decl);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rule.nodes;\n    }\n    /**\n     * Return true if brackets node is \"not\" word\n     */\n\n  }, {\n    key: \"isNot\",\n    value: function isNot(node) {\n      return typeof node === 'string' && /not\\s*/i.test(node);\n    }\n    /**\n     * Return true if brackets node is \"or\" word\n     */\n\n  }, {\n    key: \"isOr\",\n    value: function isOr(node) {\n      return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n    }\n    /**\n     * Return true if brackets node is (prop: value)\n     */\n\n  }, {\n    key: \"isProp\",\n    value: function isProp(node) {\n      return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n    }\n    /**\n     * Return true if prefixed property has no unprefixed\n     */\n\n  }, {\n    key: \"isHack\",\n    value: function isHack(all, unprefixed) {\n      var check = new RegExp(\"(\\\\(|\\\\s)\".concat(utils.escapeRegexp(unprefixed), \":\"));\n      return !check.test(all);\n    }\n    /**\n     * Return true if we need to remove node\n     */\n\n  }, {\n    key: \"toRemove\",\n    value: function toRemove(str, all) {\n      var _this$parse3 = this.parse(str),\n          _this$parse4 = _slicedToArray(_this$parse3, 2),\n          prop = _this$parse4[0],\n          value = _this$parse4[1];\n\n      var unprefixed = this.all.unprefixed(prop);\n      var cleaner = this.all.cleaner();\n\n      if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n        return true;\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(cleaner.values('remove', unprefixed)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var checker = _step3.value;\n\n          if (checker.check(value)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return false;\n    }\n    /**\n     * Remove all unnecessary prefixes\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(nodes, all) {\n      var i = 0;\n\n      while (i < nodes.length) {\n        if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n          if (this.toRemove(nodes[i][0], all)) {\n            nodes.splice(i, 2);\n            continue;\n          }\n\n          i += 2;\n          continue;\n        }\n\n        if (typeof nodes[i] === 'object') {\n          nodes[i] = this.remove(nodes[i], all);\n        }\n\n        i += 1;\n      }\n\n      return nodes;\n    }\n    /**\n     * Clean brackets with one child\n     */\n\n  }, {\n    key: \"cleanBrackets\",\n    value: function cleanBrackets(nodes) {\n      var _this = this;\n\n      return nodes.map(function (i) {\n        if (typeof i !== 'object') {\n          return i;\n        }\n\n        if (i.length === 1 && typeof i[0] === 'object') {\n          return _this.cleanBrackets(i[0]);\n        }\n\n        return _this.cleanBrackets(i);\n      });\n    }\n    /**\n     * Add \" or \" between properties and convert it to brackets format\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(progress) {\n      var result = [''];\n\n      var _iterator4 = _createForOfIteratorHelper(progress),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var i = _step4.value;\n          result.push([\"\".concat(i.prop, \": \").concat(i.value)]);\n          result.push(' or ');\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      result[result.length - 1] = '';\n      return result;\n    }\n    /**\n     * Compress value functions into a string nodes\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize(nodes) {\n      var _this2 = this;\n\n      if (typeof nodes !== 'object') {\n        return nodes;\n      }\n\n      nodes = nodes.filter(function (i) {\n        return i !== '';\n      });\n\n      if (typeof nodes[0] === 'string') {\n        var firstNode = nodes[0].trim();\n\n        if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {\n          return [brackets.stringify(nodes)];\n        }\n      }\n\n      return nodes.map(function (i) {\n        return _this2.normalize(i);\n      });\n    }\n    /**\n     * Add prefixes\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(nodes, all) {\n      var _this3 = this;\n\n      return nodes.map(function (i) {\n        if (_this3.isProp(i)) {\n          var prefixed = _this3.prefixed(i[0]);\n\n          if (prefixed.length > 1) {\n            return _this3.convert(prefixed);\n          }\n\n          return i;\n        }\n\n        if (typeof i === 'object') {\n          return _this3.add(i, all);\n        }\n\n        return i;\n      });\n    }\n    /**\n     * Add prefixed declaration\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(rule) {\n      var ast = brackets.parse(rule.params);\n      ast = this.normalize(ast);\n      ast = this.remove(ast, rule.params);\n      ast = this.add(ast, rule.params);\n      ast = this.cleanBrackets(ast);\n      rule.params = brackets.stringify(ast);\n    }\n    /**\n     * Check global options\n     */\n\n  }, {\n    key: \"disabled\",\n    value: function disabled(node) {\n      if (!this.all.options.grid) {\n        if (node.prop === 'display' && node.value.includes('grid')) {\n          return true;\n        }\n\n        if (node.prop.includes('grid') || node.prop === 'justify-items') {\n          return true;\n        }\n      }\n\n      if (this.all.options.flexbox === false) {\n        if (node.prop === 'display' && node.value.includes('flex')) {\n          return true;\n        }\n\n        var other = ['order', 'justify-content', 'align-items', 'align-content'];\n\n        if (node.prop.includes('flex') || other.includes(node.prop)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return Supports;\n}();\n\nmodule.exports = Supports;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/supports.js"],"names":["featureQueries","require","feature","parse","Browsers","brackets","Value","utils","data","supported","browser","stats","versions","version","support","test","push","Supports","Prefixes","all","prefixerCache","filtered","browsers","selected","filter","i","includes","options","str","parts","split","prop","value","trim","rule","first","append","raws","before","virtual","disabled","nodes","result","warn","prefixer","add","process","decl","values","save","node","length","unprefixed","check","RegExp","escapeRegexp","cleaner","remove","isHack","checker","isNot","isProp","isOr","toRemove","splice","map","cleanBrackets","progress","firstNode","stringify","normalize","prefixed","convert","ast","params","grid","flexbox","other","module","exports"],"mappings":"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","sourcesContent":["let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')\nlet { feature } = require('caniuse-lite')\nlet { parse } = require('postcss')\n\nlet Browsers = require('./browsers')\nlet brackets = require('./brackets')\nlet Value = require('./value')\nlet utils = require('./utils')\n\nlet data = feature(featureQueries)\n\nlet supported = []\nfor (let browser in data.stats) {\n  let versions = data.stats[browser]\n  for (let version in versions) {\n    let support = versions[version]\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version)\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes\n    this.all = all\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i)\n    })\n\n    let browsers = new Browsers(\n      this.all.browsers.data,\n      filtered,\n      this.all.options\n    )\n    this.prefixerCache = new this.Prefixes(\n      this.all.data,\n      browsers,\n      this.all.options\n    )\n    return this.prefixerCache\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse(str) {\n    let parts = str.split(':')\n    let prop = parts[0]\n    let value = parts[1]\n    if (!value) value = ''\n    return [prop.trim(), value.trim()]\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual(str) {\n    let [prop, value] = this.parse(str)\n    let rule = parse('a{}').first\n    rule.append({ prop, value, raws: { before: '' } })\n    return rule\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed(str) {\n    let rule = this.virtual(str)\n    if (this.disabled(rule.first)) {\n      return rule.nodes\n    }\n\n    let result = { warn: () => null }\n\n    let prefixer = this.prefixer().add[rule.first.prop]\n    prefixer && prefixer.process && prefixer.process(rule.first, result)\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl)\n      }\n      Value.save(this.all, decl)\n    }\n\n    return rule.nodes\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp(node) {\n    return (\n      typeof node === 'object' &&\n      node.length === 1 &&\n      typeof node[0] === 'string'\n    )\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`)\n    return !check.test(all)\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str)\n    let unprefixed = this.all.unprefixed(prop)\n\n    let cleaner = this.all.cleaner()\n\n    if (\n      cleaner.remove[prop] &&\n      cleaner.remove[prop].remove &&\n      !this.isHack(all, unprefixed)\n    ) {\n      return true\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove(nodes, all) {\n    let i = 0\n    while (i < nodes.length) {\n      if (\n        !this.isNot(nodes[i - 1]) &&\n        this.isProp(nodes[i]) &&\n        this.isOr(nodes[i + 1])\n      ) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2)\n          continue\n        }\n\n        i += 2\n        continue\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all)\n      }\n\n      i += 1\n    }\n    return nodes\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0])\n      }\n\n      return this.cleanBrackets(i)\n    })\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert(progress) {\n    let result = ['']\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`])\n      result.push(' or ')\n    }\n    result[result.length - 1] = ''\n    return result\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes\n    }\n\n    nodes = nodes.filter(i => i !== '')\n\n    if (typeof nodes[0] === 'string') {\n      let firstNode = nodes[0].trim()\n\n      if (\n        firstNode.includes(':') ||\n        firstNode === 'selector' ||\n        firstNode === 'not selector'\n      ) {\n        return [brackets.stringify(nodes)]\n      }\n    }\n    return nodes.map(i => this.normalize(i))\n  }\n\n  /**\n   * Add prefixes\n   */\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0])\n        if (prefixed.length > 1) {\n          return this.convert(prefixed)\n        }\n\n        return i\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all)\n      }\n\n      return i\n    })\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process(rule) {\n    let ast = brackets.parse(rule.params)\n    ast = this.normalize(ast)\n    ast = this.remove(ast, rule.params)\n    ast = this.add(ast, rule.params)\n    ast = this.cleanBrackets(ast)\n    rule.params = brackets.stringify(ast)\n  }\n\n  /**\n   * Check global options\n   */\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content']\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Supports\n"]},"metadata":{},"sourceType":"script"}