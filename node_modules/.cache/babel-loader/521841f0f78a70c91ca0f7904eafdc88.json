{"ast":null,"code":"var _slicedToArray = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar OldSelector = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OldSelector(selector, prefix) {\n    _classCallCheck(this, OldSelector);\n\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(function (x) {\n      return [selector.prefixed(x), selector.regexp(x)];\n    });\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n\n\n  _createClass(OldSelector, [{\n    key: \"isHack\",\n    value: function isHack(rule) {\n      var index = rule.parent.index(rule) + 1;\n      var rules = rule.parent.nodes;\n\n      while (index < rules.length) {\n        var before = rules[index].selector;\n\n        if (!before) {\n          return true;\n        }\n\n        if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n          return false;\n        }\n\n        var some = false;\n\n        var _iterator = _createForOfIteratorHelper(this.prefixeds),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                string = _step$value[0],\n                regexp = _step$value[1];\n\n            if (before.includes(string) && before.match(regexp)) {\n              some = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!some) {\n          return true;\n        }\n\n        index += 1;\n      }\n\n      return true;\n    }\n    /**\n     * Does rule contain an unnecessary prefixed selector\n     */\n\n  }, {\n    key: \"check\",\n    value: function check(rule) {\n      if (!rule.selector.includes(this.prefixed)) {\n        return false;\n      }\n\n      if (!rule.selector.match(this.regexp)) {\n        return false;\n      }\n\n      if (this.isHack(rule)) {\n        return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return OldSelector;\n}();\n\nmodule.exports = OldSelector;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/old-selector.js"],"names":["OldSelector","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","rule","index","parent","rules","nodes","length","before","includes","match","some","string","isHack","module","exports"],"mappings":";;;;;;;;IAAMA,W;;;AACJ,uBAAYC,QAAZ,EAAsBC,MAAtB,EAA8B;AAAA;;AAC5B,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,QAAL,GAAgBF,QAAQ,CAACE,QAAT,CAAkB,KAAKD,MAAvB,CAAhB;AACA,SAAKE,MAAL,GAAcH,QAAQ,CAACG,MAAT,CAAgB,KAAKF,MAArB,CAAd;AAEA,SAAKG,SAAL,GAAiBJ,QAAQ,CACtBK,QADc,GAEdC,GAFc,CAEV,UAAAC,CAAC;AAAA,aAAI,CAACP,QAAQ,CAACE,QAAT,CAAkBK,CAAlB,CAAD,EAAuBP,QAAQ,CAACG,MAAT,CAAgBI,CAAhB,CAAvB,CAAJ;AAAA,KAFS,CAAjB;AAIA,SAAKC,UAAL,GAAkBR,QAAQ,CAACS,IAA3B;AACA,SAAKC,UAAL,GAAkBV,QAAQ,CAACG,MAAT,EAAlB;AACD;AAED;AACF;AACA;;;;;WACE,gBAAOQ,IAAP,EAAa;AACX,UAAIC,KAAK,GAAGD,IAAI,CAACE,MAAL,CAAYD,KAAZ,CAAkBD,IAAlB,IAA0B,CAAtC;AACA,UAAIG,KAAK,GAAGH,IAAI,CAACE,MAAL,CAAYE,KAAxB;;AAEA,aAAOH,KAAK,GAAGE,KAAK,CAACE,MAArB,EAA6B;AAC3B,YAAIC,MAAM,GAAGH,KAAK,CAACF,KAAD,CAAL,CAAaZ,QAA1B;;AACA,YAAI,CAACiB,MAAL,EAAa;AACX,iBAAO,IAAP;AACD;;AAED,YAAIA,MAAM,CAACC,QAAP,CAAgB,KAAKV,UAArB,KAAoCS,MAAM,CAACE,KAAP,CAAa,KAAKT,UAAlB,CAAxC,EAAuE;AACrE,iBAAO,KAAP;AACD;;AAED,YAAIU,IAAI,GAAG,KAAX;;AAV2B,mDAWE,KAAKhB,SAXP;AAAA;;AAAA;AAW3B,8DAA6C;AAAA;AAAA,gBAAnCiB,MAAmC;AAAA,gBAA3BlB,MAA2B;;AAC3C,gBAAIc,MAAM,CAACC,QAAP,CAAgBG,MAAhB,KAA2BJ,MAAM,CAACE,KAAP,CAAahB,MAAb,CAA/B,EAAqD;AACnDiB,cAAAA,IAAI,GAAG,IAAP;AACA;AACD;AACF;AAhB0B;AAAA;AAAA;AAAA;AAAA;;AAkB3B,YAAI,CAACA,IAAL,EAAW;AACT,iBAAO,IAAP;AACD;;AAEDR,QAAAA,KAAK,IAAI,CAAT;AACD;;AAED,aAAO,IAAP;AACD;AAED;AACF;AACA;;;;WACE,eAAMD,IAAN,EAAY;AACV,UAAI,CAACA,IAAI,CAACX,QAAL,CAAckB,QAAd,CAAuB,KAAKhB,QAA5B,CAAL,EAA4C;AAC1C,eAAO,KAAP;AACD;;AACD,UAAI,CAACS,IAAI,CAACX,QAAL,CAAcmB,KAAd,CAAoB,KAAKhB,MAAzB,CAAL,EAAuC;AACrC,eAAO,KAAP;AACD;;AACD,UAAI,KAAKmB,MAAL,CAAYX,IAAZ,CAAJ,EAAuB;AACrB,eAAO,KAAP;AACD;;AACD,aAAO,IAAP;AACD;;;;;;AAGHY,MAAM,CAACC,OAAP,GAAiBzB,WAAjB","sourcesContent":["class OldSelector {\n  constructor(selector, prefix) {\n    this.prefix = prefix\n    this.prefixed = selector.prefixed(this.prefix)\n    this.regexp = selector.regexp(this.prefix)\n\n    this.prefixeds = selector\n      .possible()\n      .map(x => [selector.prefixed(x), selector.regexp(x)])\n\n    this.unprefixed = selector.name\n    this.nameRegexp = selector.regexp()\n  }\n\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n  isHack(rule) {\n    let index = rule.parent.index(rule) + 1\n    let rules = rule.parent.nodes\n\n    while (index < rules.length) {\n      let before = rules[index].selector\n      if (!before) {\n        return true\n      }\n\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n        return false\n      }\n\n      let some = false\n      for (let [string, regexp] of this.prefixeds) {\n        if (before.includes(string) && before.match(regexp)) {\n          some = true\n          break\n        }\n      }\n\n      if (!some) {\n        return true\n      }\n\n      index += 1\n    }\n\n    return true\n  }\n\n  /**\n   * Does rule contain an unnecessary prefixed selector\n   */\n  check(rule) {\n    if (!rule.selector.includes(this.prefixed)) {\n      return false\n    }\n    if (!rule.selector.match(this.regexp)) {\n      return false\n    }\n    if (this.isHack(rule)) {\n      return false\n    }\n    return true\n  }\n}\n\nmodule.exports = OldSelector\n"]},"metadata":{},"sourceType":"script"}