{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar Prefixer = require('./prefixer');\n\nvar OldValue = require('./old-value');\n\nvar vendor = require('./vendor');\n\nvar utils = require('./utils');\n\nvar Value = /*#__PURE__*/function (_Prefixer) {\n  \"use strict\";\n\n  _inherits(Value, _Prefixer);\n\n  var _super = _createSuper(Value);\n\n  function Value() {\n    _classCallCheck(this, Value);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Value, [{\n    key: \"check\",\n    value:\n    /**\n     * Is declaration need to be prefixed\n     */\n    function check(decl) {\n      var value = decl.value;\n\n      if (!value.includes(this.name)) {\n        return false;\n      }\n\n      return !!value.match(this.regexp());\n    }\n    /**\n     * Lazy regexp loading\n     */\n\n  }, {\n    key: \"regexp\",\n    value: function regexp() {\n      return this.regexpCache || (this.regexpCache = utils.regexp(this.name));\n    }\n    /**\n     * Add prefix to values in string\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(string, prefix) {\n      return string.replace(this.regexp(), \"$1\".concat(prefix, \"$2\"));\n    }\n    /**\n     * Get value with comments if it was not changed\n     */\n\n  }, {\n    key: \"value\",\n    value: function value(decl) {\n      if (decl.raws.value && decl.raws.value.value === decl.value) {\n        return decl.raws.value.raw;\n      } else {\n        return decl.value;\n      }\n    }\n    /**\n     * Save values with next prefixed token\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(decl, prefix) {\n      if (!decl._autoprefixerValues) {\n        decl._autoprefixerValues = {};\n      }\n\n      var value = decl._autoprefixerValues[prefix] || this.value(decl);\n      var before;\n\n      do {\n        before = value;\n        value = this.replace(value, prefix);\n        if (value === false) return;\n      } while (value !== before);\n\n      decl._autoprefixerValues[prefix] = value;\n    }\n    /**\n     * Return function to fast find prefixed value\n     */\n\n  }, {\n    key: \"old\",\n    value: function old(prefix) {\n      return new OldValue(this.name, prefix + this.name);\n    }\n  }], [{\n    key: \"save\",\n    value:\n    /**\n     * Clone decl for each prefixed values\n     */\n    function save(prefixes, decl) {\n      var _this = this;\n\n      var prop = decl.prop;\n      var result = [];\n\n      var _loop = function _loop(prefix) {\n        var value = decl._autoprefixerValues[prefix];\n\n        if (value === decl.value) {\n          return \"continue\";\n        }\n\n        var item = void 0;\n        var propPrefix = vendor.prefix(prop);\n\n        if (propPrefix === '-pie-') {\n          return \"continue\";\n        }\n\n        if (propPrefix === prefix) {\n          item = decl.value = value;\n          result.push(item);\n          return \"continue\";\n        }\n\n        var prefixed = prefixes.prefixed(prop, prefix);\n        var rule = decl.parent;\n\n        if (!rule.every(function (i) {\n          return i.prop !== prefixed;\n        })) {\n          result.push(item);\n          return \"continue\";\n        }\n\n        var trimmed = value.replace(/\\s+/, ' ');\n        var already = rule.some(function (i) {\n          return i.prop === decl.prop && i.value.replace(/\\s+/, ' ') === trimmed;\n        });\n\n        if (already) {\n          result.push(item);\n          return \"continue\";\n        }\n\n        var cloned = _this.clone(decl, {\n          value: value\n        });\n\n        item = decl.parent.insertBefore(decl, cloned);\n        result.push(item);\n      };\n\n      for (var prefix in decl._autoprefixerValues) {\n        var _ret = _loop(prefix);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return result;\n    }\n  }]);\n\n  return Value;\n}(Prefixer);\n\nmodule.exports = Value;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/value.js"],"names":["Prefixer","require","OldValue","vendor","utils","Value","decl","value","includes","name","match","regexp","regexpCache","string","prefix","replace","raws","raw","_autoprefixerValues","before","prefixes","prop","result","item","propPrefix","push","prefixed","rule","parent","every","i","trimmed","already","some","cloned","clone","insertBefore","module","exports"],"mappings":"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","sourcesContent":["let Prefixer = require('./prefixer')\nlet OldValue = require('./old-value')\nlet vendor = require('./vendor')\nlet utils = require('./utils')\n\nclass Value extends Prefixer {\n  /**\n   * Clone decl for each prefixed values\n   */\n  static save(prefixes, decl) {\n    let prop = decl.prop\n    let result = []\n\n    for (let prefix in decl._autoprefixerValues) {\n      let value = decl._autoprefixerValues[prefix]\n\n      if (value === decl.value) {\n        continue\n      }\n\n      let item\n      let propPrefix = vendor.prefix(prop)\n\n      if (propPrefix === '-pie-') {\n        continue\n      }\n\n      if (propPrefix === prefix) {\n        item = decl.value = value\n        result.push(item)\n        continue\n      }\n\n      let prefixed = prefixes.prefixed(prop, prefix)\n      let rule = decl.parent\n\n      if (!rule.every(i => i.prop !== prefixed)) {\n        result.push(item)\n        continue\n      }\n\n      let trimmed = value.replace(/\\s+/, ' ')\n      let already = rule.some(\n        i => i.prop === decl.prop && i.value.replace(/\\s+/, ' ') === trimmed\n      )\n\n      if (already) {\n        result.push(item)\n        continue\n      }\n\n      let cloned = this.clone(decl, { value })\n      item = decl.parent.insertBefore(decl, cloned)\n\n      result.push(item)\n    }\n\n    return result\n  }\n\n  /**\n   * Is declaration need to be prefixed\n   */\n  check(decl) {\n    let value = decl.value\n    if (!value.includes(this.name)) {\n      return false\n    }\n\n    return !!value.match(this.regexp())\n  }\n\n  /**\n   * Lazy regexp loading\n   */\n  regexp() {\n    return this.regexpCache || (this.regexpCache = utils.regexp(this.name))\n  }\n\n  /**\n   * Add prefix to values in string\n   */\n  replace(string, prefix) {\n    return string.replace(this.regexp(), `$1${prefix}$2`)\n  }\n\n  /**\n   * Get value with comments if it was not changed\n   */\n  value(decl) {\n    if (decl.raws.value && decl.raws.value.value === decl.value) {\n      return decl.raws.value.raw\n    } else {\n      return decl.value\n    }\n  }\n\n  /**\n   * Save values with next prefixed token\n   */\n  add(decl, prefix) {\n    if (!decl._autoprefixerValues) {\n      decl._autoprefixerValues = {}\n    }\n    let value = decl._autoprefixerValues[prefix] || this.value(decl)\n\n    let before\n    do {\n      before = value\n      value = this.replace(value, prefix)\n      if (value === false) return\n    } while (value !== before)\n\n    decl._autoprefixerValues[prefix] = value\n  }\n\n  /**\n   * Return function to fast find prefixed value\n   */\n  old(prefix) {\n    return new OldValue(this.name, prefix + this.name)\n  }\n}\n\nmodule.exports = Value\n"]},"metadata":{},"sourceType":"script"}