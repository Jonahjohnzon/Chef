{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _get = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/nasni/Desktop/Illumino/illumino/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Declaration = /*#__PURE__*/function (_Prefixer) {\n  \"use strict\";\n\n  _inherits(Declaration, _Prefixer);\n\n  var _super = _createSuper(Declaration);\n\n  function Declaration() {\n    _classCallCheck(this, Declaration);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Declaration, [{\n    key: \"check\",\n    value:\n    /**\n     * Always true, because we already get prefixer by property name\n     */\n    function\n      /* decl */\n    check() {\n      return true;\n    }\n    /**\n     * Return prefixed version of property\n     */\n\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(prop, prefix) {\n      return prefix + prop;\n    }\n    /**\n     * Return unprefixed version of property\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize(prop) {\n      return prop;\n    }\n    /**\n     * Check `value`, that it contain other prefixes, rather than `prefix`\n     */\n\n  }, {\n    key: \"otherPrefixes\",\n    value: function otherPrefixes(value, prefix) {\n      var _iterator = _createForOfIteratorHelper(Browsers.prefixes()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var other = _step.value;\n\n          if (other === prefix) {\n            continue;\n          }\n\n          if (value.includes(other)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n    /**\n     * Set prefix to declaration\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(decl, prefix) {\n      decl.prop = this.prefixed(decl.prop, prefix);\n      return decl;\n    }\n    /**\n     * Should we use visual cascade for prefixes\n     */\n\n  }, {\n    key: \"needCascade\",\n    value: function needCascade(decl) {\n      if (!decl._autoprefixerCascade) {\n        decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw('before').includes('\\n');\n      }\n\n      return decl._autoprefixerCascade;\n    }\n    /**\n     * Return maximum length of possible prefixed property\n     */\n\n  }, {\n    key: \"maxPrefixed\",\n    value: function maxPrefixed(prefixes, decl) {\n      if (decl._autoprefixerMax) {\n        return decl._autoprefixerMax;\n      }\n\n      var max = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(prefixes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var prefix = _step2.value;\n          prefix = utils.removeNote(prefix);\n\n          if (prefix.length > max) {\n            max = prefix.length;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      decl._autoprefixerMax = max;\n      return decl._autoprefixerMax;\n    }\n    /**\n     * Calculate indentation to create visual cascade\n     */\n\n  }, {\n    key: \"calcBefore\",\n    value: function calcBefore(prefixes, decl) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var max = this.maxPrefixed(prefixes, decl);\n      var diff = max - utils.removeNote(prefix).length;\n      var before = decl.raw('before');\n\n      if (diff > 0) {\n        before += Array(diff).fill(' ').join('');\n      }\n\n      return before;\n    }\n    /**\n     * Remove visual cascade\n     */\n\n  }, {\n    key: \"restoreBefore\",\n    value: function restoreBefore(decl) {\n      var lines = decl.raw('before').split('\\n');\n      var min = lines[lines.length - 1];\n      this.all.group(decl).up(function (prefixed) {\n        var array = prefixed.raw('before').split('\\n');\n        var last = array[array.length - 1];\n\n        if (last.length < min.length) {\n          min = last;\n        }\n      });\n      lines[lines.length - 1] = min;\n      decl.raws.before = lines.join('\\n');\n    }\n    /**\n     * Clone and insert new declaration\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(decl, prefix, prefixes) {\n      var cloned = this.set(this.clone(decl), prefix);\n      if (!cloned) return undefined;\n      var already = decl.parent.some(function (i) {\n        return i.prop === cloned.prop && i.value === cloned.value;\n      });\n\n      if (already) {\n        return undefined;\n      }\n\n      if (this.needCascade(decl)) {\n        cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n      }\n\n      return decl.parent.insertBefore(decl, cloned);\n    }\n    /**\n     * Did this declaration has this prefix above\n     */\n\n  }, {\n    key: \"isAlready\",\n    value: function isAlready(decl, prefixed) {\n      var already = this.all.group(decl).up(function (i) {\n        return i.prop === prefixed;\n      });\n\n      if (!already) {\n        already = this.all.group(decl).down(function (i) {\n          return i.prop === prefixed;\n        });\n      }\n\n      return already;\n    }\n    /**\n     * Clone and add prefixes for declaration\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(decl, prefix, prefixes, result) {\n      var prefixed = this.prefixed(decl.prop, prefix);\n\n      if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {\n        return undefined;\n      }\n\n      return this.insert(decl, prefix, prefixes, result);\n    }\n    /**\n     * Add spaces for visual cascade\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(decl, result) {\n      if (!this.needCascade(decl)) {\n        _get(_getPrototypeOf(Declaration.prototype), \"process\", this).call(this, decl, result);\n\n        return;\n      }\n\n      var prefixes = _get(_getPrototypeOf(Declaration.prototype), \"process\", this).call(this, decl, result);\n\n      if (!prefixes || !prefixes.length) {\n        return;\n      }\n\n      this.restoreBefore(decl);\n      decl.raws.before = this.calcBefore(prefixes, decl);\n    }\n    /**\n     * Return list of prefixed properties to clean old prefixes\n     */\n\n  }, {\n    key: \"old\",\n    value: function old(prop, prefix) {\n      return [this.prefixed(prop, prefix)];\n    }\n  }]);\n\n  return Declaration;\n}(Prefixer);\n\nmodule.exports = Declaration;","map":{"version":3,"sources":["C:/Users/nasni/Desktop/Illumino/illumino/node_modules/autoprefixer/lib/declaration.js"],"names":["Prefixer","require","Browsers","utils","Declaration","prop","prefix","value","prefixes","other","includes","decl","prefixed","_autoprefixerCascade","all","options","cascade","raw","_autoprefixerMax","max","removeNote","length","maxPrefixed","diff","before","Array","fill","join","lines","split","min","group","up","array","last","raws","cloned","set","clone","undefined","already","parent","some","i","needCascade","calcBefore","insertBefore","down","result","isAlready","otherPrefixes","insert","restoreBefore","module","exports"],"mappings":"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","sourcesContent":["let Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Declaration extends Prefixer {\n  /**\n   * Always true, because we already get prefixer by property name\n   */\n  check(/* decl */) {\n    return true\n  }\n\n  /**\n   * Return prefixed version of property\n   */\n  prefixed(prop, prefix) {\n    return prefix + prop\n  }\n\n  /**\n   * Return unprefixed version of property\n   */\n  normalize(prop) {\n    return prop\n  }\n\n  /**\n   * Check `value`, that it contain other prefixes, rather than `prefix`\n   */\n  otherPrefixes(value, prefix) {\n    for (let other of Browsers.prefixes()) {\n      if (other === prefix) {\n        continue\n      }\n      if (value.includes(other)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Set prefix to declaration\n   */\n  set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix)\n    return decl\n  }\n\n  /**\n   * Should we use visual cascade for prefixes\n   */\n  needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade =\n        this.all.options.cascade !== false && decl.raw('before').includes('\\n')\n    }\n    return decl._autoprefixerCascade\n  }\n\n  /**\n   * Return maximum length of possible prefixed property\n   */\n  maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax\n    }\n\n    let max = 0\n    for (let prefix of prefixes) {\n      prefix = utils.removeNote(prefix)\n      if (prefix.length > max) {\n        max = prefix.length\n      }\n    }\n    decl._autoprefixerMax = max\n\n    return decl._autoprefixerMax\n  }\n\n  /**\n   * Calculate indentation to create visual cascade\n   */\n  calcBefore(prefixes, decl, prefix = '') {\n    let max = this.maxPrefixed(prefixes, decl)\n    let diff = max - utils.removeNote(prefix).length\n\n    let before = decl.raw('before')\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('')\n    }\n\n    return before\n  }\n\n  /**\n   * Remove visual cascade\n   */\n  restoreBefore(decl) {\n    let lines = decl.raw('before').split('\\n')\n    let min = lines[lines.length - 1]\n\n    this.all.group(decl).up(prefixed => {\n      let array = prefixed.raw('before').split('\\n')\n      let last = array[array.length - 1]\n      if (last.length < min.length) {\n        min = last\n      }\n    })\n\n    lines[lines.length - 1] = min\n    decl.raws.before = lines.join('\\n')\n  }\n\n  /**\n   * Clone and insert new declaration\n   */\n  insert(decl, prefix, prefixes) {\n    let cloned = this.set(this.clone(decl), prefix)\n    if (!cloned) return undefined\n\n    let already = decl.parent.some(\n      i => i.prop === cloned.prop && i.value === cloned.value\n    )\n    if (already) {\n      return undefined\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\n    }\n    return decl.parent.insertBefore(decl, cloned)\n  }\n\n  /**\n   * Did this declaration has this prefix above\n   */\n  isAlready(decl, prefixed) {\n    let already = this.all.group(decl).up(i => i.prop === prefixed)\n    if (!already) {\n      already = this.all.group(decl).down(i => i.prop === prefixed)\n    }\n    return already\n  }\n\n  /**\n   * Clone and add prefixes for declaration\n   */\n  add(decl, prefix, prefixes, result) {\n    let prefixed = this.prefixed(decl.prop, prefix)\n    if (\n      this.isAlready(decl, prefixed) ||\n      this.otherPrefixes(decl.value, prefix)\n    ) {\n      return undefined\n    }\n    return this.insert(decl, prefix, prefixes, result)\n  }\n\n  /**\n   * Add spaces for visual cascade\n   */\n  process(decl, result) {\n    if (!this.needCascade(decl)) {\n      super.process(decl, result)\n      return\n    }\n\n    let prefixes = super.process(decl, result)\n\n    if (!prefixes || !prefixes.length) {\n      return\n    }\n\n    this.restoreBefore(decl)\n    decl.raws.before = this.calcBefore(prefixes, decl)\n  }\n\n  /**\n   * Return list of prefixed properties to clean old prefixes\n   */\n  old(prop, prefix) {\n    return [this.prefixed(prop, prefix)]\n  }\n}\n\nmodule.exports = Declaration\n"]},"metadata":{},"sourceType":"script"}